# Quickstart 81: MVP 1.0 - Basic Game Server

â† [Back to Checkpoint A Overview](80-arena60-checkpoint-a-overview.md) | [Quickstart Index](README.md)

**Arena60 Checkpoint A - MVP 1.0: Basic Game Server**

**Duration**: 2-3 weeks  
**Difficulty**: â­â­â­ (Moderate)  
**Prerequisites**: Phase 1 M1.1-1.4 complete  
**Goal**: Core infrastructure and basic multiplayer gameplay  
**Lines**: ~1800

---

## ğŸ“– Overview

**Build the foundation: WebSocket server + 60 TPS game loop + player movement**

This is the first MVP where you integrate everything from Phase 1 into a real production project. No more isolated milestones - this is a complete, working multiplayer game server.

**What You'll Build**:
- WebSocket server handling 100+ concurrent connections
- 60 TPS game loop (16.6ms tick rate)
- Player movement synchronized across clients (WASD + mouse)
- Basic circle-circle collision detection
- PostgreSQL user management (login, user accounts)
- HTML/Canvas client for testing

**Learning Goals**:
- âœ… Apply Phase 1 knowledge to production context
- âœ… Handle concurrent game sessions
- âœ… Synchronize player state across network
- âœ… Optimize for real-time performance (60 TPS)
- âœ… Implement proper error handling
- âœ… Write production-quality tests

**Success Criteria**:
- 2+ players can connect simultaneously
- Players move in sync across all clients (<50ms latency)
- Server maintains stable 60 TPS with 10 players
- No crashes during 30-minute stress test
- Unit tests pass (â‰¥70% coverage)
- Client visually smooth (no jitter)

---

## ğŸ“š Table of Contents

1. [MVP 1.0 Specification](#1-mvp-10-specification)
2. [Architecture Design](#2-architecture-design)
3. [Database Schema](#3-database-schema)
4. [Server Implementation](#4-server-implementation)
5. [Game Loop (60 TPS)](#5-game-loop-60-tps)
6. [Player Movement](#6-player-movement)
7. [Network Protocol](#7-network-protocol)
8. [Client Implementation](#8-client-implementation)
9. [Testing](#9-testing)
10. [Deployment](#10-deployment)
11. [Performance Optimization](#11-performance-optimization)
12. [Troubleshooting](#12-troubleshooting)

---

## 1. MVP 1.0 Specification

### 1.1 Features

**Must Have**:
- âœ… WebSocket server (boost.beast)
- âœ… User authentication (username/password)
- âœ… 60 TPS game loop (16.6ms fixed timestep)
- âœ… Player movement (WASD keys)
- âœ… Mouse aiming (rotation)
- âœ… Basic collision (world boundaries)
- âœ… State synchronization (broadcast to all players)
- âœ… PostgreSQL user storage

**Out of Scope** (for MVP 1.1+):
- âŒ Combat/shooting (MVP 1.1)
- âŒ Matchmaking (MVP 1.2)
- âŒ Statistics (MVP 1.3)
- âŒ Spectator mode
- âŒ Replay system

### 1.2 Technical Requirements

**Performance**:
- Tick rate: Stable 60 TPS (Â±2 TPS tolerance)
- Latency: p99 â‰¤ 50ms (client â†’ server â†’ broadcast)
- Concurrent players: 10+ in single game session
- Memory: < 50 MB for single game instance
- CPU: < 25% of single core at 60 TPS

**Quality**:
- Unit test coverage: â‰¥70%
- No memory leaks (Valgrind clean)
- No race conditions (ThreadSanitizer clean)
- Graceful shutdown (no abrupt disconnects)

### 1.3 Deliverables

- [ ] Working server binary (`./arena60_server`)
- [ ] HTML/Canvas client (`client/index.html`)
- [ ] Unit tests (`tests/unit/`)
- [ ] Integration test (2 clients connecting)
- [ ] Performance benchmark report
- [ ] Evidence pack (`docs/evidence/checkpoint-a/mvp-1.0/`)
  - [ ] Architecture diagram
  - [ ] Screenshot (2 players moving)
  - [ ] Performance graph (tick rate over time)
  - [ ] Test coverage report

---

## 2. Architecture Design

### 2.1 Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MVP 1.0 Architecture                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚         Main Thread                     â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚           â”‚
â”‚  â”‚  â”‚   WebSocket Server            â”‚     â”‚           â”‚
â”‚  â”‚  â”‚   (boost.beast)               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚                               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Accept connections         â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Receive messages           â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Send broadcasts            â”‚     â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚           â”‚
â”‚  â”‚              â”‚                          â”‚           â”‚
â”‚  â”‚              â–¼                          â”‚           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚           â”‚
â”‚  â”‚  â”‚   Connection Manager          â”‚     â”‚           â”‚
â”‚  â”‚  â”‚                               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Session pool               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Message queue (lockfree)   â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Broadcast all clients      â”‚     â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                      â”‚                                  â”‚
â”‚                      â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚         Game Thread                     â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚           â”‚
â”‚  â”‚  â”‚   Game Loop (60 TPS)          â”‚     â”‚           â”‚
â”‚  â”‚  â”‚                               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  Every 16.6ms:               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  1. Read input queue          â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  2. Update player positions   â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  3. Check collisions          â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  4. Generate state snapshot   â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  5. Send to network thread    â”‚     â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚           â”‚
â”‚  â”‚              â”‚                          â”‚           â”‚
â”‚  â”‚              â–¼                          â”‚           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚           â”‚
â”‚  â”‚  â”‚   Game State                  â”‚     â”‚           â”‚
â”‚  â”‚  â”‚                               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - std::map<id, Player>       â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - World bounds               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Tick counter               â”‚     â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                      â”‚                                  â”‚
â”‚                      â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚         Database Thread (Optional)      â”‚           â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚           â”‚
â”‚  â”‚  â”‚   PostgreSQL Client           â”‚     â”‚           â”‚
â”‚  â”‚  â”‚                               â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - User authentication        â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Async queries              â”‚     â”‚           â”‚
â”‚  â”‚  â”‚  - Connection pool (5 conns)  â”‚     â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Threading Model

**3 Thread Architecture**:

```cpp
// Main Thread (Network I/O)
boost::asio::io_context io_context;
WebSocketServer server(io_context, 8080);

// Game Thread (60 TPS)
std::thread game_thread([&]() {
    GameLoop loop(60);  // 60 TPS
    loop.run();
});

// Database Thread (Optional - for async queries)
std::thread db_thread([&]() {
    DatabaseWorker worker;
    worker.processQueue();
});

io_context.run();  // Blocks on main thread
```

**Why 3 Threads?**:
- **Main Thread**: boost.asio is single-threaded, handles all network I/O
- **Game Thread**: Game logic isolated, no blocking I/O, predictable timing
- **DB Thread**: Async database queries don't block game loop

**Communication Between Threads**:
```cpp
// Thread-safe lockless queues
boost::lockfree::spsc_queue<InputEvent> input_queue(1000);    // Network â†’ Game
boost::lockfree::spsc_queue<StateUpdate> output_queue(100);   // Game â†’ Network
boost::lockfree::spsc_queue<DbQuery> db_queue(100);           // Game â†’ Database
```

### 2.3 Data Flow

```
Client Input Flow:
  Client (WASD press)
    â†’ WebSocket message
    â†’ Server receives (Main Thread)
    â†’ Push to input_queue
    â†’ Game Thread reads queue
    â†’ Update player position
    â†’ Generate state snapshot
    â†’ Push to output_queue
    â†’ Main Thread reads queue
    â†’ Broadcast to all clients
    â†’ Clients render (Canvas)

Timing:
  Total latency: 16.6ms (1 tick) + network RTT (~10-30ms) = ~30-50ms
```

---

## 3. Database Schema

### 3.1 PostgreSQL Schema

```sql
-- File: scripts/init_db.sql

-- Users table
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    elo INTEGER DEFAULT 1200,
    created_at TIMESTAMP DEFAULT NOW(),
    last_login TIMESTAMP
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_elo ON users(elo DESC);

-- Active sessions (in-memory, optional)
CREATE TABLE sessions (
    user_id BIGINT PRIMARY KEY REFERENCES users(id),
    session_token VARCHAR(255) NOT NULL,
    ip_address INET,
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_sessions_token ON sessions(session_token);
CREATE INDEX idx_sessions_expires ON sessions(expires_at);

-- Sample data for testing
INSERT INTO users (username, password_hash, elo) VALUES
    ('alice', '$2b$12$...', 1200),
    ('bob', '$2b$12$...', 1250),
    ('charlie', '$2b$12$...', 1180);
```

### 3.2 Connection String

```bash
# .env file
DATABASE_URL=postgresql://arena60:password@localhost:5432/arena60_dev
```

```cpp
// C++ code
const std::string conn_string = 
    "host=localhost "
    "port=5432 "
    "dbname=arena60_dev "
    "user=arena60 "
    "password=password";
```

---

## 4. Server Implementation

### 4.1 Project Structure

```
server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp                      # Entry point
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ game_loop.h
â”‚   â”‚   â”œâ”€â”€ game_loop.cpp             # 60 TPS tick manager
â”‚   â”‚   â”œâ”€â”€ timer.h
â”‚   â”‚   â””â”€â”€ timer.cpp                 # High-precision timer
â”‚   â”‚
â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â”œâ”€â”€ player.h
â”‚   â”‚   â”œâ”€â”€ player.cpp                # Player entity
â”‚   â”‚   â”œâ”€â”€ game_state.h
â”‚   â”‚   â”œâ”€â”€ game_state.cpp            # Game world state
â”‚   â”‚   â””â”€â”€ collision.h               # Collision detection
â”‚   â”‚
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ websocket_server.h
â”‚   â”‚   â”œâ”€â”€ websocket_server.cpp      # boost.beast server
â”‚   â”‚   â”œâ”€â”€ session.h
â”‚   â”‚   â”œâ”€â”€ session.cpp               # WebSocket session
â”‚   â”‚   â””â”€â”€ connection_manager.h      # Session pool
â”‚   â”‚
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ postgres_client.h
â”‚       â”œâ”€â”€ postgres_client.cpp       # PostgreSQL wrapper
â”‚       â””â”€â”€ user_repository.h         # User CRUD
â”‚
â”œâ”€â”€ include/
â”‚   â””â”€â”€ arena60/
â”‚       â”œâ”€â”€ types.h                   # Common types
â”‚       â””â”€â”€ config.h                  # Configuration
â”‚
â””â”€â”€ CMakeLists.txt
```

### 4.2 Main Entry Point

```cpp
// src/main.cpp
#include <iostream>
#include <thread>
#include <boost/asio.hpp>
#include "network/websocket_server.h"
#include "core/game_loop.h"
#include "storage/postgres_client.h"

int main(int argc, char* argv[]) {
    try {
        // Configuration
        const uint16_t port = 8080;
        const int tick_rate = 60;  // 60 TPS
        
        // Database connection
        auto db = std::make_shared<PostgresClient>(
            "host=localhost dbname=arena60_dev user=arena60 password=password"
        );
        
        if (!db->connect()) {
            std::cerr << "Failed to connect to database" << std::endl;
            return 1;
        }
        
        std::cout << "Database connected" << std::endl;
        
        // Create game state (shared between threads)
        auto game_state = std::make_shared<GameState>();
        
        // Communication queues
        auto input_queue = std::make_shared<boost::lockfree::spsc_queue<InputEvent>>(1000);
        auto output_queue = std::make_shared<boost::lockfree::spsc_queue<StateUpdate>>(100);
        
        // Start game loop thread
        GameLoop game_loop(tick_rate, game_state, input_queue, output_queue);
        std::thread game_thread([&game_loop]() {
            game_loop.run();
        });
        
        std::cout << "Game loop started at " << tick_rate << " TPS" << std::endl;
        
        // Start WebSocket server (main thread)
        boost::asio::io_context io_context;
        WebSocketServer server(io_context, port, game_state, db, input_queue, output_queue);
        
        std::cout << "WebSocket server listening on port " << port << std::endl;
        std::cout << "Open http://localhost:" << port << " in your browser" << std::endl;
        
        // Run until Ctrl+C
        io_context.run();
        
        // Cleanup
        game_loop.stop();
        game_thread.join();
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```

### 4.3 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(arena60 VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Compiler flags
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(-Wall -Wextra -Wpedantic -O3)
endif()

# Find Boost
find_package(Boost 1.82 REQUIRED COMPONENTS system)

# Find PostgreSQL
find_package(PostgreSQL REQUIRED)

# Find Threads
find_package(Threads REQUIRED)

# Server executable
add_executable(arena60_server
    src/main.cpp
    src/core/game_loop.cpp
    src/core/timer.cpp
    src/game/player.cpp
    src/game/game_state.cpp
    src/network/websocket_server.cpp
    src/network/session.cpp
    src/storage/postgres_client.cpp
)

target_include_directories(arena60_server
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/include
        ${PostgreSQL_INCLUDE_DIRS}
)

target_link_libraries(arena60_server
    PRIVATE
        Boost::system
        Threads::Threads
        ${PostgreSQL_LIBRARIES}
)

# Enable testing
enable_testing()
add_subdirectory(tests)
```

---

## 5. Game Loop (60 TPS)

### 5.1 High-Precision Timer

```cpp
// include/arena60/types.h
#include <chrono>

namespace arena60 {

using Clock = std::chrono::steady_clock;
using TimePoint = Clock::time_point;
using Duration = std::chrono::nanoseconds;

inline double toSeconds(Duration d) {
    return std::chrono::duration<double>(d).count();
}

inline double toMilliseconds(Duration d) {
    return std::chrono::duration<double, std::milli>(d).count();
}

} // namespace arena60
```

```cpp
// src/core/timer.h
#pragma once
#include "arena60/types.h"

namespace arena60 {

class Timer {
public:
    Timer() : start_(Clock::now()) {}
    
    void reset() {
        start_ = Clock::now();
    }
    
    Duration elapsed() const {
        return Clock::now() - start_;
    }
    
    double elapsedSeconds() const {
        return toSeconds(elapsed());
    }
    
    double elapsedMilliseconds() const {
        return toMilliseconds(elapsed());
    }
    
private:
    TimePoint start_;
};

} // namespace arena60
```

### 5.2 Fixed Timestep Game Loop

```cpp
// src/core/game_loop.h
#pragma once
#include <atomic>
#include <memory>
#include <thread>
#include <boost/lockfree/spsc_queue.hpp>
#include "arena60/types.h"
#include "game/game_state.h"

namespace arena60 {

struct InputEvent {
    uint64_t player_id;
    std::string type;  // "move", "rotate"
    float x, y;        // Position or direction
};

struct StateUpdate {
    uint64_t tick;
    std::vector<PlayerState> players;
};

class GameLoop {
public:
    GameLoop(int target_tps, 
             std::shared_ptr<GameState> game_state,
             std::shared_ptr<boost::lockfree::spsc_queue<InputEvent>> input_queue,
             std::shared_ptr<boost::lockfree::spsc_queue<StateUpdate>> output_queue);
    
    void run();
    void stop();
    
    uint64_t getCurrentTick() const { return tick_count_; }
    double getAverageTPS() const;
    
private:
    void tick();
    void processInputs();
    void updatePhysics(float dt);
    void broadcastState();
    
    int target_tps_;
    Duration target_frame_time_;
    std::atomic<bool> running_{true};
    uint64_t tick_count_{0};
    
    std::shared_ptr<GameState> game_state_;
    std::shared_ptr<boost::lockfree::spsc_queue<InputEvent>> input_queue_;
    std::shared_ptr<boost::lockfree::spsc_queue<StateUpdate>> output_queue_;
    
    // Performance tracking
    TimePoint last_report_time_;
    uint64_t ticks_since_report_{0};
};

} // namespace arena60
```

```cpp
// src/core/game_loop.cpp
#include "core/game_loop.h"
#include "core/timer.h"
#include <iostream>
#include <thread>

namespace arena60 {

GameLoop::GameLoop(int target_tps,
                   std::shared_ptr<GameState> game_state,
                   std::shared_ptr<boost::lockfree::spsc_queue<InputEvent>> input_queue,
                   std::shared_ptr<boost::lockfree::spsc_queue<StateUpdate>> output_queue)
    : target_tps_(target_tps)
    , target_frame_time_(std::chrono::nanoseconds(1'000'000'000 / target_tps))
    , game_state_(game_state)
    , input_queue_(input_queue)
    , output_queue_(output_queue)
    , last_report_time_(Clock::now())
{
}

void GameLoop::run() {
    std::cout << "[GameLoop] Starting at " << target_tps_ << " TPS" << std::endl;
    
    Timer frame_timer;
    Duration accumulator{0};
    
    while (running_) {
        // Measure frame time
        auto frame_start = Clock::now();
        
        // Fixed timestep update
        accumulator += frame_timer.elapsed();
        frame_timer.reset();
        
        while (accumulator >= target_frame_time_) {
            tick();
            accumulator -= target_frame_time_;
            tick_count_++;
            ticks_since_report_++;
        }
        
        // Report TPS every second
        auto now = Clock::now();
        auto elapsed = now - last_report_time_;
        if (elapsed >= std::chrono::seconds(1)) {
            double actual_tps = ticks_since_report_ / toSeconds(elapsed);
            std::cout << "[GameLoop] TPS: " << actual_tps 
                      << " (target: " << target_tps_ << ")" << std::endl;
            
            last_report_time_ = now;
            ticks_since_report_ = 0;
        }
        
        // Sleep to avoid busy-wait
        auto frame_time = Clock::now() - frame_start;
        auto sleep_time = target_frame_time_ - frame_time;
        
        if (sleep_time > Duration{0}) {
            std::this_thread::sleep_for(sleep_time);
        }
    }
    
    std::cout << "[GameLoop] Stopped after " << tick_count_ << " ticks" << std::endl;
}

void GameLoop::stop() {
    running_ = false;
}

void GameLoop::tick() {
    // 1. Process inputs from network thread
    processInputs();
    
    // 2. Update game physics
    float dt = 1.0f / target_tps_;  // e.g., 0.0166s for 60 TPS
    updatePhysics(dt);
    
    // 3. Broadcast state to network thread
    broadcastState();
}

void GameLoop::processInputs() {
    InputEvent event;
    int processed = 0;
    
    while (input_queue_->pop(event)) {
        auto player = game_state_->getPlayer(event.player_id);
        if (!player) continue;
        
        if (event.type == "move") {
            player->velocity.x = event.x;
            player->velocity.y = event.y;
        } else if (event.type == "rotate") {
            player->rotation = std::atan2(event.y, event.x);
        }
        
        processed++;
    }
    
    // Optional: log if input queue is full
    if (processed >= 900) {
        std::cerr << "[GameLoop] Warning: Input queue near capacity (" 
                  << processed << "/1000)" << std::endl;
    }
}

void GameLoop::updatePhysics(float dt) {
    const float PLAYER_SPEED = 200.0f;  // pixels per second
    const float WORLD_WIDTH = 1920.0f;
    const float WORLD_HEIGHT = 1080.0f;
    const float PLAYER_RADIUS = 20.0f;
    
    game_state_->forEachPlayer([&](Player& player) {
        // Update position
        player.position.x += player.velocity.x * PLAYER_SPEED * dt;
        player.position.y += player.velocity.y * PLAYER_SPEED * dt;
        
        // World boundary collision
        player.position.x = std::clamp(player.position.x, 
                                      PLAYER_RADIUS, 
                                      WORLD_WIDTH - PLAYER_RADIUS);
        player.position.y = std::clamp(player.position.y, 
                                      PLAYER_RADIUS, 
                                      WORLD_HEIGHT - PLAYER_RADIUS);
    });
}

void GameLoop::broadcastState() {
    StateUpdate update;
    update.tick = tick_count_;
    
    game_state_->forEachPlayer([&](const Player& player) {
        PlayerState state;
        state.id = player.id;
        state.username = player.username;
        state.x = player.position.x;
        state.y = player.position.y;
        state.rotation = player.rotation;
        state.health = player.health;
        
        update.players.push_back(state);
    });
    
    // Push to output queue (non-blocking)
    if (!output_queue_->push(update)) {
        std::cerr << "[GameLoop] Warning: Output queue full, dropping state update" << std::endl;
    }
}

double GameLoop::getAverageTPS() const {
    // TODO: Track moving average
    return target_tps_;
}

} // namespace arena60
```

### 5.3 Why Fixed Timestep?

**Problem with Variable Timestep**:
```cpp
// BAD: Physics depends on frame rate
void update() {
    float dt = getDeltaTime();  // Could be 5ms, 50ms, or 200ms
    player.x += player.velocity * dt;  // Inconsistent behavior!
}
```

**Fixed Timestep Solution**:
```cpp
// GOOD: Physics always updates at 60 Hz
void update() {
    const float dt = 1.0f / 60.0f;  // Always 16.6ms
    player.x += player.velocity * dt;  // Predictable!
}
```

**Benefits**:
- Deterministic physics (same input = same output)
- Easier to debug (consistent behavior)
- Network-friendly (clients can predict)

---

## 6. Player Movement

### 6.1 Player Entity

```cpp
// src/game/player.h
#pragma once
#include <string>
#include <cstdint>

namespace arena60 {

struct Vec2 {
    float x{0.0f};
    float y{0.0f};
};

struct Player {
    uint64_t id;
    std::string username;
    Vec2 position;
    Vec2 velocity;  // Normalized direction (-1 to 1)
    float rotation{0.0f};  // Radians
    int health{100};
    bool is_alive{true};
};

struct PlayerState {
    uint64_t id;
    std::string username;
    float x, y;
    float rotation;
    int health;
};

} // namespace arena60
```

```cpp
// src/game/player.cpp
#include "game/player.h"

namespace arena60 {

// Player methods (if needed)

} // namespace arena60
```

### 6.2 Game State Manager

```cpp
// src/game/game_state.h
#pragma once
#include "game/player.h"
#include <map>
#include <mutex>
#include <functional>

namespace arena60 {

class GameState {
public:
    void addPlayer(uint64_t id, const std::string& username);
    void removePlayer(uint64_t id);
    Player* getPlayer(uint64_t id);
    
    void forEachPlayer(std::function<void(Player&)> func);
    void forEachPlayer(std::function<void(const Player&)> func) const;
    
    size_t getPlayerCount() const;
    
private:
    mutable std::mutex mutex_;
    std::map<uint64_t, Player> players_;
};

} // namespace arena60
```

```cpp
// src/game/game_state.cpp
#include "game/game_state.h"
#include <iostream>

namespace arena60 {

void GameState::addPlayer(uint64_t id, const std::string& username) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    Player player;
    player.id = id;
    player.username = username;
    player.position = {960.0f, 540.0f};  // Center of 1920x1080
    player.velocity = {0.0f, 0.0f};
    player.rotation = 0.0f;
    player.health = 100;
    player.is_alive = true;
    
    players_[id] = player;
    
    std::cout << "[GameState] Player " << username << " (ID: " << id << ") joined" << std::endl;
}

void GameState::removePlayer(uint64_t id) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = players_.find(id);
    if (it != players_.end()) {
        std::cout << "[GameState] Player " << it->second.username 
                  << " (ID: " << id << ") left" << std::endl;
        players_.erase(it);
    }
}

Player* GameState::getPlayer(uint64_t id) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = players_.find(id);
    return (it != players_.end()) ? &it->second : nullptr;
}

void GameState::forEachPlayer(std::function<void(Player&)> func) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (auto& [id, player] : players_) {
        func(player);
    }
}

void GameState::forEachPlayer(std::function<void(const Player&)> func) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    for (const auto& [id, player] : players_) {
        func(player);
    }
}

size_t GameState::getPlayerCount() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return players_.size();
}

} // namespace arena60
```

### 6.3 Input Handling

**Client-side** (JavaScript):
```javascript
// Track key state
const keys = {
    w: false,
    a: false,
    s: false,
    d: false
};

document.addEventListener('keydown', (e) => {
    if (e.key in keys) {
        keys[e.key] = true;
        sendInput();
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key in keys) {
        keys[e.key] = false;
        sendInput();
    }
});

// Send input to server
function sendInput() {
    // Calculate velocity vector from keys
    let vx = 0, vy = 0;
    if (keys.w) vy -= 1;
    if (keys.s) vy += 1;
    if (keys.a) vx -= 1;
    if (keys.d) vx += 1;
    
    // Normalize diagonal movement
    if (vx !== 0 && vy !== 0) {
        const len = Math.sqrt(vx * vx + vy * vy);
        vx /= len;
        vy /= len;
    }
    
    ws.send(JSON.stringify({
        type: 'move',
        x: vx,
        y: vy
    }));
}

// Mouse movement for rotation
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate angle from player to mouse
    const dx = mouseX - myPlayer.x;
    const dy = mouseY - myPlayer.y;
    const angle = Math.atan2(dy, dx);
    
    ws.send(JSON.stringify({
        type: 'rotate',
        angle: angle
    }));
});
```

**Server-side** (C++):
```cpp
// In WebSocket message handler
void Session::handleMessage(const std::string& message) {
    // Parse JSON (using nlohmann/json or boost.json)
    auto json = nlohmann::json::parse(message);
    
    std::string type = json["type"];
    
    if (type == "move") {
        InputEvent event;
        event.player_id = this->user_id_;
        event.type = "move";
        event.x = json["x"];  // -1 to 1
        event.y = json["y"];  // -1 to 1
        
        input_queue_->push(event);
        
    } else if (type == "rotate") {
        InputEvent event;
        event.player_id = this->user_id_;
        event.type = "rotate";
        event.x = std::cos(json["angle"]);
        event.y = std::sin(json["angle"]);
        
        input_queue_->push(event);
    }
}
```

---

## 7. Network Protocol

### 7.1 Message Types

**Client â†’ Server**:

```json
// Login
{
    "type": "login",
    "username": "alice",
    "password": "password123"
}

// Move input
{
    "type": "move",
    "x": -0.707,
    "y": 0.707
}

// Rotate (aim)
{
    "type": "rotate",
    "angle": 1.57
}

// Logout
{
    "type": "logout"
}
```

**Server â†’ Client**:

```json
// Login success
{
    "type": "login_success",
    "user_id": 123,
    "username": "alice",
    "elo": 1200
}

// Login failure
{
    "type": "login_failure",
    "error": "Invalid credentials"
}

// Game state (60 times per second)
{
    "type": "state",
    "tick": 3600,
    "players": [
        {
            "id": 123,
            "username": "alice",
            "x": 960.5,
            "y": 540.2,
            "rotation": 1.57,
            "health": 100
        },
        {
            "id": 456,
            "username": "bob",
            "x": 1200.3,
            "y": 700.8,
            "rotation": -0.78,
            "health": 80
        }
    ]
}

// Player joined
{
    "type": "player_joined",
    "id": 789,
    "username": "charlie"
}

// Player left
{
    "type": "player_left",
    "id": 789
}
```

### 7.2 WebSocket Server Implementation

```cpp
// src/network/websocket_server.h
#pragma once
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <memory>
#include <set>

namespace beast = boost::beast;
namespace websocket = beast::websocket;
namespace net = boost::asio;
using tcp = net::ip::tcp;

namespace arena60 {

class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket socket, /* dependencies */);
    void run();
    void send(const std::string& message);
    
private:
    void doRead();
    void onRead(beast::error_code ec, std::size_t bytes_transferred);
    void doWrite();
    
    websocket::stream<tcp::socket> ws_;
    beast::flat_buffer buffer_;
    std::queue<std::string> write_queue_;
    uint64_t user_id_{0};
};

class WebSocketServer {
public:
    WebSocketServer(net::io_context& ioc, 
                   uint16_t port,
                   std::shared_ptr<GameState> game_state,
                   std::shared_ptr<PostgresClient> db,
                   std::shared_ptr<boost::lockfree::spsc_queue<InputEvent>> input_queue,
                   std::shared_ptr<boost::lockfree::spsc_queue<StateUpdate>> output_queue);
    
private:
    void doAccept();
    void onAccept(beast::error_code ec, tcp::socket socket);
    void broadcastGameState();
    
    net::io_context& ioc_;
    tcp::acceptor acceptor_;
    std::shared_ptr<GameState> game_state_;
    std::shared_ptr<PostgresClient> db_;
    std::shared_ptr<boost::lockfree::spsc_queue<InputEvent>> input_queue_;
    std::shared_ptr<boost::lockfree::spsc_queue<StateUpdate>> output_queue_;
    
    std::set<std::shared_ptr<Session>> sessions_;
    net::steady_timer broadcast_timer_;
};

} // namespace arena60
```

*(Implementation continues in next section - file is getting long)*

---

## 8. Client Implementation

### 8.1 HTML Structure

```html
<!-- client/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena60 - MVP 1.0</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="login-screen">
        <h1>Arena60</h1>
        <input type="text" id="username" placeholder="Username" />
        <input type="password" id="password" placeholder="Password" />
        <button id="login-btn">Login</button>
        <div id="error-message"></div>
    </div>
    
    <div id="game-screen" style="display: none;">
        <div id="hud">
            <div id="player-info">
                <span id="player-name"></span>
                <span id="player-health">Health: 100</span>
            </div>
            <div id="fps">FPS: 60</div>
        </div>
        <canvas id="game-canvas" width="1920" height="1080"></canvas>
    </div>
    
    <script src="game.js"></script>
</body>
</html>
```

### 8.2 Game Client (JavaScript)

```javascript
// client/game.js
class GameClient {
    constructor() {
        this.ws = null;
        this.myPlayerId = null;
        this.players = new Map();
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.keys = { w: false, a: false, s: false, d: false };
        
        this.setupEventListeners();
    }
    
    connect(username, password) {
        this.ws = new WebSocket('ws://localhost:8080');
        
        this.ws.onopen = () => {
            console.log('Connected to server');
            this.login(username, password);
        };
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            document.getElementById('error-message').textContent = 
                'Connection error. Is server running?';
        };
        
        this.ws.onclose = () => {
            console.log('Disconnected from server');
            this.showLoginScreen();
        };
    }
    
    login(username, password) {
        this.ws.send(JSON.stringify({
            type: 'login',
            username: username,
            password: password
        }));
    }
    
    handleMessage(data) {
        switch (data.type) {
            case 'login_success':
                this.myPlayerId = data.user_id;
                document.getElementById('player-name').textContent = data.username;
                this.showGameScreen();
                this.startGameLoop();
                break;
                
            case 'login_failure':
                document.getElementById('error-message').textContent = data.error;
                break;
                
            case 'state':
                this.updateGameState(data);
                break;
                
            case 'player_joined':
                console.log(`Player ${data.username} joined`);
                break;
                
            case 'player_left':
                this.players.delete(data.id);
                break;
        }
    }
    
    updateGameState(data) {
        // Update players map
        this.players.clear();
        for (const playerData of data.players) {
            this.players.set(playerData.id, playerData);
        }
    }
    
    sendInput() {
        let vx = 0, vy = 0;
        if (this.keys.w) vy -= 1;
        if (this.keys.s) vy += 1;
        if (this.keys.a) vx -= 1;
        if (this.keys.d) vx += 1;
        
        // Normalize diagonal
        if (vx !== 0 && vy !== 0) {
            const len = Math.sqrt(vx * vx + vy * vy);
            vx /= len;
            vy /= len;
        }
        
        this.ws.send(JSON.stringify({
            type: 'move',
            x: vx,
            y: vy
        }));
    }
    
    startGameLoop() {
        const render = () => {
            this.render();
            requestAnimationFrame(render);
        };
        requestAnimationFrame(render);
    }
    
    render() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        
        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        ctx.strokeStyle = '#16213e';
        ctx.lineWidth = 1;
        for (let x = 0; x < canvas.width; x += 100) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += 100) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // Draw players
        for (const [id, player] of this.players) {
            const isMe = (id === this.myPlayerId);
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = isMe ? '#0f3460' : '#e94560';
            ctx.fill();
            ctx.strokeStyle = isMe ? '#00d4ff' : '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw direction indicator
            const dirX = player.x + Math.cos(player.rotation) * 30;
            const dirY = player.y + Math.sin(player.rotation) * 30;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(dirX, dirY);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw username
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.username, player.x, player.y - 30);
            
            // Draw health bar
            const barWidth = 40;
            const barHeight = 5;
            const healthPercent = player.health / 100;
            ctx.fillStyle = '#333';
            ctx.fillRect(player.x - barWidth/2, player.y + 25, barWidth, barHeight);
            ctx.fillStyle = healthPercent > 0.3 ? '#00ff00' : '#ff0000';
            ctx.fillRect(player.x - barWidth/2, player.y + 25, barWidth * healthPercent, barHeight);
        }
    }
    
    setupEventListeners() {
        // Login button
        document.getElementById('login-btn').addEventListener('click', () => {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            if (!username || !password) {
                document.getElementById('error-message').textContent = 
                    'Please enter username and password';
                return;
            }
            
            this.connect(username, password);
        });
        
        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key in this.keys) {
                this.keys[e.key] = true;
                this.sendInput();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key in this.keys) {
                this.keys[e.key] = false;
                this.sendInput();
            }
        });
        
        // Mouse aim
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.myPlayerId) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const myPlayer = this.players.get(this.myPlayerId);
            if (!myPlayer) return;
            
            const dx = mouseX - myPlayer.x;
            const dy = mouseY - myPlayer.y;
            const angle = Math.atan2(dy, dx);
            
            this.ws.send(JSON.stringify({
                type: 'rotate',
                x: Math.cos(angle),
                y: Math.sin(angle)
            }));
        });
    }
    
    showLoginScreen() {
        document.getElementById('login-screen').style.display = 'block';
        document.getElementById('game-screen').style.display = 'none';
    }
    
    showGameScreen() {
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('game-screen').style.display = 'block';
    }
}

// Initialize game client
const client = new GameClient();
```

---

## 9. Testing

### 9.1 Unit Tests

```cpp
// tests/unit/test_game_loop.cpp
#include <gtest/gtest.h>
#include "core/game_loop.h"

TEST(GameLoopTest, TickRateCalculation) {
    // 60 TPS = 16.666ms per tick
    int tps = 60;
    auto frame_time = std::chrono::nanoseconds(1'000'000'000 / tps);
    
    EXPECT_EQ(16'666'666, frame_time.count());
}

TEST(GameLoopTest, PlayerMovement) {
    // Test player moves correctly with velocity
    Player player;
    player.position = {100.0f, 100.0f};
    player.velocity = {1.0f, 0.0f};  // Moving right
    
    float dt = 1.0f / 60.0f;  // 16.6ms
    float speed = 200.0f;     // pixels/second
    
    player.position.x += player.velocity.x * speed * dt;
    
    EXPECT_NEAR(103.33f, player.position.x, 0.01f);
}
```

### 9.2 Integration Tests

```cpp
// tests/integration/test_client_connection.cpp
#include <gtest/gtest.h>
#include <boost/asio.hpp>
#include <thread>
#include "network/websocket_server.h"

TEST(IntegrationTest, TwoClientsConnect) {
    // Start server
    boost::asio::io_context ioc;
    auto server = std::make_shared<WebSocketServer>(ioc, 8080, /* ... */);
    
    std::thread server_thread([&]() {
        ioc.run();
    });
    
    // Connect client 1
    // Connect client 2
    // Verify both see each other's state
    
    // Cleanup
    ioc.stop();
    server_thread.join();
}
```

### 9.3 Performance Tests

```cpp
// tests/performance/benchmark_tick_rate.cpp
#include <gtest/gtest.h>
#include "core/game_loop.h"

TEST(PerformanceTest, Maintains60TPSWith10Players) {
    auto game_state = std::make_shared<GameState>();
    
    // Add 10 players
    for (int i = 0; i < 10; i++) {
        game_state->addPlayer(i, "player" + std::to_string(i));
    }
    
    // Run game loop for 5 seconds
    GameLoop loop(60, game_state, /* queues */);
    
    auto start = std::chrono::steady_clock::now();
    std::thread game_thread([&]() {
        loop.run();
    });
    
    std::this_thread::sleep_for(std::chrono::seconds(5));
    loop.stop();
    game_thread.join();
    
    auto elapsed = std::chrono::steady_clock::now() - start;
    auto ticks = loop.getCurrentTick();
    auto actual_tps = ticks / (elapsed.count() / 1e9);
    
    // Expect 60 Â± 2 TPS
    EXPECT_NEAR(60.0, actual_tps, 2.0);
}
```

---

## 10. Deployment

### 10.1 Docker Compose

```yaml
# deployments/docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: arena60
      POSTGRES_PASSWORD: password
      POSTGRES_DB: arena60_dev
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ../../scripts/init_db.sql:/docker-entrypoint-initdb.d/init.sql

  server:
    build:
      context: ../..
      dockerfile: deployments/docker/Dockerfile
    ports:
      - "8080:8080"
    depends_on:
      - postgres
    environment:
      DATABASE_URL: postgresql://arena60:password@postgres:5432/arena60_dev

volumes:
  postgres-data:
```

### 10.2 Dockerfile

```dockerfile
# deployments/docker/Dockerfile
FROM ubuntu:22.04 AS build

RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    libboost-all-dev \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY . .

RUN mkdir build && cd build && \
    cmake .. && \
    make -j$(nproc)

FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    libboost-system1.74.0 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

COPY --from=build /app/build/arena60_server /usr/local/bin/
COPY --from=build /app/client /app/client

EXPOSE 8080

CMD ["arena60_server"]
```

### 10.3 Build and Run

```bash
# Build and start
cd deployments/docker
docker-compose up --build

# Logs
docker-compose logs -f server

# Stop
docker-compose down
```

---

## 11. Performance Optimization

### 11.1 Common Bottlenecks

**Problem 1: Mutex Contention**
```cpp
// BAD: Lock held too long
std::lock_guard<std::mutex> lock(mutex_);
for (auto& [id, player] : players_) {
    updatePlayer(player);  // Expensive operation!
}

// GOOD: Minimize critical section
std::vector<Player> snapshot;
{
    std::lock_guard<std::mutex> lock(mutex_);
    for (const auto& [id, player] : players_) {
        snapshot.push_back(player);
    }
}
for (auto& player : snapshot) {
    updatePlayer(player);  // No lock held
}
```

**Problem 2: Unnecessary Allocations**
```cpp
// BAD: String allocation every frame
std::string message = "{\"type\":\"state\",\"tick\":" + std::to_string(tick) + "}";

// GOOD: Use string buffer
std::ostringstream oss;
oss << "{\"type\":\"state\",\"tick\":" << tick << "}";
```

### 11.2 Profiling

```bash
# CPU profiling with perf
perf record -g ./arena60_server
perf report

# Memory profiling with Valgrind
valgrind --tool=massif ./arena60_server
ms_print massif.out.<pid>

# Thread sanitizer
cmake -DCMAKE_CXX_FLAGS="-fsanitize=thread" ..
```

---

## 12. Troubleshooting

### 12.1 Common Issues

**Issue 1: Tick Rate Drops Below 60**

**Symptoms**: TPS output shows 45-50 instead of 60

**Causes**:
- Game loop doing blocking I/O
- Too many players (>50)
- Inefficient physics calculations

**Solutions**:
```cpp
// Profile game loop
Timer tick_timer;
processInputs();
std::cout << "processInputs: " << tick_timer.elapsedMilliseconds() << "ms" << std::endl;

tick_timer.reset();
updatePhysics(dt);
std::cout << "updatePhysics: " << tick_timer.elapsedMilliseconds() << "ms" << std::endl;

// Target: Each section < 5ms
```

**Issue 2: Players Jitter/Stutter**

**Symptoms**: Players appear to teleport or move erratically

**Causes**:
- Network packet loss
- State updates not synchronized
- Client interpolation missing

**Solutions**:
```javascript
// Client-side interpolation
function interpolate(currentState, previousState, alpha) {
    player.x = lerp(previousState.x, currentState.x, alpha);
    player.y = lerp(previousState.y, currentState.y, alpha);
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}
```

**Issue 3: Memory Leak**

**Symptoms**: Memory usage increases over time

**Causes**:
- Dangling pointers
- Circular shared_ptr references
- Unclosed WebSocket sessions

**Solutions**:
```bash
# Run with Valgrind
valgrind --leak-check=full ./arena60_server

# Check for leaks
# HEAP SUMMARY:
#   definitely lost: 0 bytes in 0 blocks
#   indirectly lost: 0 bytes in 0 blocks
```

---

## ğŸ¯ MVP 1.0 Complete!

**You've successfully implemented**:
- âœ… WebSocket server with 100+ concurrent connections
- âœ… 60 TPS game loop with fixed timestep
- âœ… Player movement synchronized across clients
- âœ… PostgreSQL user management
- âœ… HTML/Canvas client
- âœ… Unit and integration tests

**Evidence Pack Checklist**:
- [ ] Screenshot: 2+ players moving simultaneously
- [ ] Video: 30-second clip showing smooth movement
- [ ] Performance graph: Tick rate over 5 minutes (should be flat at 60)
- [ ] Test coverage report: >70%

**Next MVP**:
- [MVP 1.1: Combat System â†’](82-mvp-1.1-combat-system.md) (2-3 weeks)
  - Projectile shooting
  - Collision detection
  - Damage system
  - Death and respawn

---

â† [Back to Checkpoint A Overview](80-arena60-checkpoint-a-overview.md) | [Next: MVP 1.1 â†’](82-mvp-1.1-combat-system.md)
