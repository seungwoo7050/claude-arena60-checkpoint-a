# Quickstart 82: MVP 1.1 - Combat System

â† [Back to MVP 1.0](81-mvp-1.0-basic-game-server.md) | [Quickstart Index](README.md)

**Arena60 Checkpoint A - MVP 1.1: Combat System**

**Duration**: 2-3 weeks  
**Difficulty**: â­â­â­â­ (Hard)  
**Prerequisites**: MVP 1.0 complete  
**Goal**: Add shooting, collision detection, damage, and death mechanics  
**Lines**: ~1500

---

## ğŸ“– Overview

**Transform static movement into real-time combat**

In MVP 1.0, players could move around but nothing happened when they interacted. Now we add the core combat loop: shoot projectiles, detect collisions, apply damage, handle deaths, and respawn.

**What You'll Build**:
- Projectile system (click to shoot)
- Circle-circle collision detection (players vs projectiles)
- Damage system (20 HP per hit)
- Death mechanics (health reaches 0)
- Respawn system (3-second delay)
- Kill feed UI
- Score tracking

**Learning Goals**:
- âœ… Implement efficient collision detection (O(nÂ²) â†’ spatial partitioning)
- âœ… Handle entity lifecycle (spawn, update, destroy)
- âœ… Synchronize combat events across network
- âœ… Manage game state consistency
- âœ… Optimize for 60 TPS with 100+ projectiles

**Success Criteria**:
- 2 players can shoot each other
- Collision detection works reliably (<1% false negative)
- Deaths and respawns synchronized across clients
- Server maintains 60 TPS with 50+ active projectiles
- No desync issues (health values match across clients)
- Unit tests for collision detection pass

---

## ğŸ“š Table of Contents

1. [MVP 1.1 Specification](#1-mvp-11-specification)
2. [Architecture Changes](#2-architecture-changes)
3. [Projectile System](#3-projectile-system)
4. [Collision Detection](#4-collision-detection)
5. [Damage System](#5-damage-system)
6. [Death and Respawn](#6-death-and-respawn)
7. [Network Protocol](#7-network-protocol)
8. [Client Implementation](#8-client-implementation)
9. [Performance Optimization](#9-performance-optimization)
10. [Testing](#10-testing)
11. [Troubleshooting](#11-troubleshooting)
12. [Portfolio Showcase](#12-portfolio-showcase)

---

## 1. MVP 1.1 Specification

### 1.1 Features

**Must Have**:
- âœ… Left-click to shoot projectile
- âœ… Projectiles move at constant velocity (500 px/s)
- âœ… Circle-circle collision detection
- âœ… Damage on hit (20 HP per projectile)
- âœ… Death when health reaches 0
- âœ… 3-second respawn delay
- âœ… Respawn at random position
- âœ… Kill feed (who killed whom)
- âœ… Score tracking (kills/deaths)

**Out of Scope** (for MVP 1.2+):
- âŒ Different weapon types
- âŒ Power-ups or abilities
- âŒ Matchmaking (MVP 1.2)
- âŒ Statistics persistence (MVP 1.3)

### 1.2 Technical Requirements

**Performance**:
- Tick rate: Stable 60 TPS with 50+ projectiles
- Collision checks: < 5ms per tick (at 10 players + 50 projectiles)
- Memory: < 100 MB with 100 active projectiles
- Latency: Hit registration within 50ms

**Quality**:
- Collision accuracy: â‰¥99% (< 1% false negatives)
- No ghost bullets (projectiles disappearing)
- No desync (health values consistent across clients)
- Unit test coverage: â‰¥75%

**Game Balance**:
- Projectile speed: 500 px/s
- Fire rate: 5 shots/second (200ms cooldown)
- Damage: 20 HP per hit
- Shots to kill: 5 hits (100 HP / 20 HP)
- Time to kill: ~1 second (with perfect accuracy)

### 1.3 Deliverables

- [ ] Working combat system (shoot, hit, die, respawn)
- [ ] Collision detection tests (unit + integration)
- [ ] Performance benchmark (60 TPS with 50 projectiles)
- [ ] Evidence pack (`docs/evidence/checkpoint-a/mvp-1.1/`)
  - [ ] Screenshot: Kill feed showing deaths
  - [ ] Video: 2-player combat (30 seconds)
  - [ ] Performance graph: TPS with increasing projectiles
  - [ ] Test coverage report

---

## 2. Architecture Changes

### 2.1 New Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MVP 1.1 Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Game State (MVP 1.0)                                  â”‚
â”‚  â”œâ”€â”€ std::map<id, Player>                              â”‚
â”‚  â””â”€â”€ World bounds                                      â”‚
â”‚                                                         â”‚
â”‚  + New in MVP 1.1:                                     â”‚
â”‚  â”œâ”€â”€ std::vector<Projectile> projectiles_             â”‚
â”‚  â”œâ”€â”€ std::vector<CombatEvent> combat_events_          â”‚
â”‚  â””â”€â”€ std::map<id, RespawnTimer> respawn_timers_       â”‚
â”‚                                                         â”‚
â”‚  + New Systems:                                        â”‚
â”‚  â”œâ”€â”€ ProjectileManager                                â”‚
â”‚  â”‚   â”œâ”€â”€ spawn(owner_id, pos, dir)                   â”‚
â”‚  â”‚   â”œâ”€â”€ update(dt)                                   â”‚
â”‚  â”‚   â””â”€â”€ removeOutOfBounds()                          â”‚
â”‚  â”‚                                                     â”‚
â”‚  â”œâ”€â”€ CollisionSystem                                  â”‚
â”‚  â”‚   â”œâ”€â”€ checkProjectilePlayerCollisions()           â”‚
â”‚  â”‚   â”œâ”€â”€ checkPlayerPlayerCollisions()               â”‚
â”‚  â”‚   â””â”€â”€ resolveCollision(entity1, entity2)          â”‚
â”‚  â”‚                                                     â”‚
â”‚  â”œâ”€â”€ CombatSystem                                     â”‚
â”‚  â”‚   â”œâ”€â”€ applyDamage(player, amount)                 â”‚
â”‚  â”‚   â”œâ”€â”€ handleDeath(player)                         â”‚
â”‚  â”‚   â””â”€â”€ handleRespawn(player)                       â”‚
â”‚  â”‚                                                     â”‚
â”‚  â””â”€â”€ ScoreManager                                     â”‚
â”‚      â”œâ”€â”€ incrementKills(player_id)                   â”‚
â”‚      â”œâ”€â”€ incrementDeaths(player_id)                  â”‚
â”‚      â””â”€â”€ getLeaderboard()                            â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Game Loop Updates

```cpp
// Before (MVP 1.0)
void GameLoop::tick() {
    processInputs();       // Handle WASD, mouse aim
    updatePhysics(dt);     // Move players
    broadcastState();      // Send player positions
}

// After (MVP 1.1)
void GameLoop::tick() {
    processInputs();               // + shoot inputs
    updateProjectiles(dt);         // Move projectiles
    checkCollisions();             // Detect hits
    applyCombatEvents();           // Apply damage, handle deaths
    updateRespawnTimers(dt);       // Count down respawn timers
    updatePhysics(dt);             // Move players
    broadcastState();              // + projectiles, combat events
}
```

### 2.3 State Size Comparison

```
MVP 1.0:
  Players: 10 Ã— 100 bytes = 1 KB
  Total: ~1 KB per state update

MVP 1.1:
  Players: 10 Ã— 100 bytes = 1 KB
  Projectiles: 50 Ã— 50 bytes = 2.5 KB
  Combat Events: 5 Ã— 30 bytes = 150 bytes
  Total: ~3.7 KB per state update

Bandwidth: 3.7 KB Ã— 60 TPS = 222 KB/s per client
```

---

## 3. Projectile System

### 3.1 Projectile Entity

```cpp
// include/arena60/entities.h
#pragma once
#include <cstdint>

namespace arena60 {

struct Vec2 {
    float x{0.0f};
    float y{0.0f};
    
    Vec2 operator+(const Vec2& other) const {
        return {x + other.x, y + other.y};
    }
    
    Vec2 operator*(float scalar) const {
        return {x * scalar, y * scalar};
    }
    
    float length() const {
        return std::sqrt(x * x + y * y);
    }
    
    Vec2 normalized() const {
        float len = length();
        if (len > 0.0f) {
            return {x / len, y / len};
        }
        return {0.0f, 0.0f};
    }
};

struct Projectile {
    uint64_t id;
    uint64_t owner_id;      // Who shot this
    Vec2 position;
    Vec2 velocity;          // Pixels per second
    float radius{5.0f};     // Collision radius
    int damage{20};
    float lifetime{3.0f};   // Auto-destroy after 3 seconds
    bool is_alive{true};
    
    void update(float dt) {
        position = position + velocity * dt;
        lifetime -= dt;
        if (lifetime <= 0.0f) {
            is_alive = false;
        }
    }
    
    bool isOutOfBounds(float world_width, float world_height) const {
        return position.x < -100.0f || position.x > world_width + 100.0f ||
               position.y < -100.0f || position.y > world_height + 100.0f;
    }
};

} // namespace arena60
```

### 3.2 Projectile Manager

```cpp
// src/game/projectile_manager.h
#pragma once
#include "arena60/entities.h"
#include <vector>
#include <atomic>

namespace arena60 {

class ProjectileManager {
public:
    uint64_t spawn(uint64_t owner_id, const Vec2& position, const Vec2& direction);
    void update(float dt);
    void remove(uint64_t projectile_id);
    void clear();
    
    const std::vector<Projectile>& getAll() const { return projectiles_; }
    Projectile* get(uint64_t id);
    
    size_t count() const { return projectiles_.size(); }
    
private:
    void removeDeadProjectiles();
    
    std::vector<Projectile> projectiles_;
    std::atomic<uint64_t> next_id_{1};
    
    // Configuration
    static constexpr float PROJECTILE_SPEED = 500.0f;  // px/s
    static constexpr float WORLD_WIDTH = 1920.0f;
    static constexpr float WORLD_HEIGHT = 1080.0f;
};

} // namespace arena60
```

```cpp
// src/game/projectile_manager.cpp
#include "game/projectile_manager.h"
#include <algorithm>

namespace arena60 {

uint64_t ProjectileManager::spawn(uint64_t owner_id, 
                                   const Vec2& position, 
                                   const Vec2& direction) {
    Projectile proj;
    proj.id = next_id_++;
    proj.owner_id = owner_id;
    proj.position = position;
    proj.velocity = direction.normalized() * PROJECTILE_SPEED;
    proj.radius = 5.0f;
    proj.damage = 20;
    proj.lifetime = 3.0f;
    proj.is_alive = true;
    
    projectiles_.push_back(proj);
    
    return proj.id;
}

void ProjectileManager::update(float dt) {
    // Update all projectiles
    for (auto& proj : projectiles_) {
        if (proj.is_alive) {
            proj.update(dt);
            
            // Check world bounds
            if (proj.isOutOfBounds(WORLD_WIDTH, WORLD_HEIGHT)) {
                proj.is_alive = false;
            }
        }
    }
    
    // Remove dead projectiles
    removeDeadProjectiles();
}

void ProjectileManager::remove(uint64_t projectile_id) {
    for (auto& proj : projectiles_) {
        if (proj.id == projectile_id) {
            proj.is_alive = false;
            break;
        }
    }
}

void ProjectileManager::clear() {
    projectiles_.clear();
}

Projectile* ProjectileManager::get(uint64_t id) {
    for (auto& proj : projectiles_) {
        if (proj.id == id && proj.is_alive) {
            return &proj;
        }
    }
    return nullptr;
}

void ProjectileManager::removeDeadProjectiles() {
    projectiles_.erase(
        std::remove_if(projectiles_.begin(), projectiles_.end(),
            [](const Projectile& p) { return !p.is_alive; }),
        projectiles_.end()
    );
}

} // namespace arena60
```

### 3.3 Shooting Input

```cpp
// In GameLoop::processInputs()
void GameLoop::processInputs() {
    InputEvent event;
    
    while (input_queue_->pop(event)) {
        auto player = game_state_->getPlayer(event.player_id);
        if (!player || !player->is_alive) continue;
        
        if (event.type == "move") {
            player->velocity.x = event.x;
            player->velocity.y = event.y;
            
        } else if (event.type == "rotate") {
            player->rotation = std::atan2(event.y, event.x);
            
        } else if (event.type == "shoot") {
            // Check fire rate cooldown
            auto now = Clock::now();
            auto elapsed = now - player->last_shot_time;
            
            if (elapsed >= std::chrono::milliseconds(200)) {  // 5 shots/sec
                // Spawn projectile
                Vec2 shoot_dir = {std::cos(player->rotation), 
                                 std::sin(player->rotation)};
                Vec2 spawn_pos = player->position + shoot_dir * 30.0f;  // Spawn ahead
                
                projectile_manager_->spawn(player->id, spawn_pos, shoot_dir);
                
                player->last_shot_time = now;
            }
        }
    }
}
```

---

## 4. Collision Detection

### 4.1 Circle-Circle Collision

```cpp
// src/game/collision.h
#pragma once
#include "arena60/entities.h"

namespace arena60 {

struct CollisionResult {
    bool hit;
    Vec2 normal;
    float penetration;
};

class CollisionSystem {
public:
    // Check if two circles overlap
    static bool checkCircleCircle(const Vec2& pos1, float radius1,
                                   const Vec2& pos2, float radius2);
    
    // Get detailed collision info
    static CollisionResult getCollisionInfo(const Vec2& pos1, float radius1,
                                            const Vec2& pos2, float radius2);
    
    // Distance between two points
    static float distance(const Vec2& a, const Vec2& b);
};

} // namespace arena60
```

```cpp
// src/game/collision.cpp
#include "game/collision.h"
#include <cmath>

namespace arena60 {

bool CollisionSystem::checkCircleCircle(const Vec2& pos1, float radius1,
                                        const Vec2& pos2, float radius2) {
    float dx = pos2.x - pos1.x;
    float dy = pos2.y - pos1.y;
    float distance_squared = dx * dx + dy * dy;
    float radius_sum = radius1 + radius2;
    
    return distance_squared <= (radius_sum * radius_sum);
}

CollisionResult CollisionSystem::getCollisionInfo(const Vec2& pos1, float radius1,
                                                   const Vec2& pos2, float radius2) {
    CollisionResult result;
    
    float dx = pos2.x - pos1.x;
    float dy = pos2.y - pos1.y;
    float dist = std::sqrt(dx * dx + dy * dy);
    float radius_sum = radius1 + radius2;
    
    result.hit = (dist <= radius_sum);
    
    if (result.hit && dist > 0.0f) {
        result.normal = {dx / dist, dy / dist};
        result.penetration = radius_sum - dist;
    } else {
        result.normal = {0.0f, 0.0f};
        result.penetration = 0.0f;
    }
    
    return result;
}

float CollisionSystem::distance(const Vec2& a, const Vec2& b) {
    float dx = b.x - a.x;
    float dy = b.y - a.y;
    return std::sqrt(dx * dx + dy * dy);
}

} // namespace arena60
```

### 4.2 Collision Detection in Game Loop

```cpp
// In GameLoop::checkCollisions()
void GameLoop::checkCollisions() {
    const float PLAYER_RADIUS = 20.0f;
    
    auto& projectiles = projectile_manager_->getAll();
    
    // Check projectile vs player collisions
    for (auto& proj : projectiles) {
        if (!proj.is_alive) continue;
        
        game_state_->forEachPlayer([&](Player& player) {
            // Don't check collision with shooter
            if (player.id == proj.owner_id) return;
            if (!player.is_alive) return;
            
            // Circle-circle collision
            bool hit = CollisionSystem::checkCircleCircle(
                proj.position, proj.radius,
                player.position, PLAYER_RADIUS
            );
            
            if (hit) {
                // Record combat event
                CombatEvent event;
                event.type = CombatEventType::HIT;
                event.attacker_id = proj.owner_id;
                event.victim_id = player.id;
                event.damage = proj.damage;
                event.position = player.position;
                
                combat_events_.push_back(event);
                
                // Mark projectile for removal
                proj.is_alive = false;
            }
        });
    }
    
    // Optional: Check player vs player collisions (push apart)
    // TODO: Implement player-player collision for MVP 1.2
}
```

### 4.3 Spatial Partitioning (Optional Optimization)

```cpp
// For 100+ entities, use spatial grid
class SpatialGrid {
public:
    SpatialGrid(float cell_size) : cell_size_(cell_size) {}
    
    void clear() { grid_.clear(); }
    
    void insert(uint64_t id, const Vec2& pos) {
        int x = static_cast<int>(pos.x / cell_size_);
        int y = static_cast<int>(pos.y / cell_size_);
        grid_[{x, y}].push_back(id);
    }
    
    std::vector<uint64_t> query(const Vec2& pos, float radius) {
        std::vector<uint64_t> results;
        
        int min_x = static_cast<int>((pos.x - radius) / cell_size_);
        int max_x = static_cast<int>((pos.x + radius) / cell_size_);
        int min_y = static_cast<int>((pos.y - radius) / cell_size_);
        int max_y = static_cast<int>((pos.y + radius) / cell_size_);
        
        for (int x = min_x; x <= max_x; ++x) {
            for (int y = min_y; y <= max_y; ++y) {
                auto it = grid_.find({x, y});
                if (it != grid_.end()) {
                    results.insert(results.end(), it->second.begin(), it->second.end());
                }
            }
        }
        
        return results;
    }
    
private:
    float cell_size_;
    std::map<std::pair<int, int>, std::vector<uint64_t>> grid_;
};

// Usage: Reduces O(nÂ²) to O(n)
void GameLoop::checkCollisionsOptimized() {
    SpatialGrid grid(100.0f);  // 100x100 px cells
    
    // Insert all entities
    game_state_->forEachPlayer([&](const Player& p) {
        if (p.is_alive) {
            grid.insert(p.id, p.position);
        }
    });
    
    // Check projectiles only against nearby players
    for (auto& proj : projectile_manager_->getAll()) {
        auto nearby = grid.query(proj.position, 50.0f);
        for (auto player_id : nearby) {
            // Check collision only with nearby players
        }
    }
}
```

---

## 5. Damage System

### 5.1 Combat Events

```cpp
// include/arena60/combat.h
#pragma once
#include <cstdint>
#include "arena60/entities.h"

namespace arena60 {

enum class CombatEventType {
    HIT,
    DEATH,
    RESPAWN
};

struct CombatEvent {
    CombatEventType type;
    uint64_t attacker_id;
    uint64_t victim_id;
    int damage;
    Vec2 position;  // Where event occurred
};

} // namespace arena60
```

### 5.2 Apply Combat Events

```cpp
// In GameLoop::applyCombatEvents()
void GameLoop::applyCombatEvents() {
    for (const auto& event : combat_events_) {
        if (event.type == CombatEventType::HIT) {
            auto victim = game_state_->getPlayer(event.victim_id);
            if (!victim || !victim->is_alive) continue;
            
            // Apply damage
            victim->health -= event.damage;
            
            std::cout << "[Combat] Player " << victim->username 
                      << " hit for " << event.damage << " damage (HP: " 
                      << victim->health << ")" << std::endl;
            
            // Check for death
            if (victim->health <= 0) {
                handlePlayerDeath(event.attacker_id, event.victim_id);
            }
        }
    }
    
    // Clear processed events
    combat_events_.clear();
}

void GameLoop::handlePlayerDeath(uint64_t attacker_id, uint64_t victim_id) {
    auto victim = game_state_->getPlayer(victim_id);
    auto attacker = game_state_->getPlayer(attacker_id);
    
    if (!victim) return;
    
    // Mark as dead
    victim->is_alive = false;
    victim->health = 0;
    
    // Update scores
    if (attacker) {
        attacker->kills++;
    }
    victim->deaths++;
    
    // Schedule respawn
    RespawnTimer timer;
    timer.player_id = victim_id;
    timer.remaining_time = 3.0f;  // 3 seconds
    respawn_timers_[victim_id] = timer;
    
    std::cout << "[Combat] Player " << victim->username << " killed by " 
              << (attacker ? attacker->username : "unknown") << std::endl;
    
    // Broadcast death event
    CombatEvent death_event;
    death_event.type = CombatEventType::DEATH;
    death_event.attacker_id = attacker_id;
    death_event.victim_id = victim_id;
    combat_events_for_broadcast_.push_back(death_event);
}
```

### 5.3 Health Regeneration (Optional)

```cpp
// Add to Player struct
struct Player {
    // ... existing fields
    float health_regen_rate{5.0f};  // HP per second
    TimePoint last_damage_time;
};

// In updatePhysics()
void GameLoop::updatePhysics(float dt) {
    auto now = Clock::now();
    
    game_state_->forEachPlayer([&](Player& player) {
        if (!player.is_alive) return;
        
        // Regenerate health (after 5 seconds of no damage)
        auto time_since_damage = now - player.last_damage_time;
        if (time_since_damage >= std::chrono::seconds(5)) {
            player.health += player.health_regen_rate * dt;
            player.health = std::min(player.health, 100);
        }
        
        // Update position
        // ... (existing code)
    });
}
```

---

## 6. Death and Respawn

### 6.1 Respawn Timer

```cpp
// include/arena60/respawn.h
#pragma once
#include <cstdint>

namespace arena60 {

struct RespawnTimer {
    uint64_t player_id;
    float remaining_time;  // Seconds
};

} // namespace arena60
```

```cpp
// In GameLoop::updateRespawnTimers()
void GameLoop::updateRespawnTimers(float dt) {
    std::vector<uint64_t> players_to_respawn;
    
    for (auto& [player_id, timer] : respawn_timers_) {
        timer.remaining_time -= dt;
        
        if (timer.remaining_time <= 0.0f) {
            players_to_respawn.push_back(player_id);
        }
    }
    
    // Respawn players
    for (auto player_id : players_to_respawn) {
        respawnPlayer(player_id);
        respawn_timers_.erase(player_id);
    }
}

void GameLoop::respawnPlayer(uint64_t player_id) {
    auto player = game_state_->getPlayer(player_id);
    if (!player) return;
    
    // Random spawn position
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_real_distribution<float> dist_x(100.0f, 1820.0f);
    std::uniform_real_distribution<float> dist_y(100.0f, 980.0f);
    
    player->position.x = dist_x(gen);
    player->position.y = dist_y(gen);
    player->velocity = {0.0f, 0.0f};
    player->rotation = 0.0f;
    player->health = 100;
    player->is_alive = true;
    
    std::cout << "[Combat] Player " << player->username 
              << " respawned at (" << player->position.x 
              << ", " << player->position.y << ")" << std::endl;
    
    // Broadcast respawn event
    CombatEvent respawn_event;
    respawn_event.type = CombatEventType::RESPAWN;
    respawn_event.victim_id = player_id;
    respawn_event.position = player->position;
    combat_events_for_broadcast_.push_back(respawn_event);
}
```

### 6.2 Spawn Protection (Optional)

```cpp
// Add to Player struct
struct Player {
    // ... existing fields
    bool has_spawn_protection{false};
    float spawn_protection_remaining{0.0f};
};

// In respawnPlayer()
player->has_spawn_protection = true;
player->spawn_protection_remaining = 2.0f;  // 2 seconds invulnerable

// In updatePhysics()
if (player.has_spawn_protection) {
    player.spawn_protection_remaining -= dt;
    if (player.spawn_protection_remaining <= 0.0f) {
        player.has_spawn_protection = false;
    }
}

// In checkCollisions()
if (player.has_spawn_protection) {
    return;  // Skip collision check
}
```

---

## 7. Network Protocol

### 7.1 New Message Types

**Client â†’ Server**:

```json
// Shoot input
{
    "type": "shoot"
}
```

**Server â†’ Client**:

```json
// Game state (now includes projectiles)
{
    "type": "state",
    "tick": 3600,
    "players": [
        {
            "id": 123,
            "username": "alice",
            "x": 960.5,
            "y": 540.2,
            "rotation": 1.57,
            "health": 80,
            "is_alive": true,
            "kills": 3,
            "deaths": 1
        }
    ],
    "projectiles": [
        {
            "id": 5001,
            "owner_id": 123,
            "x": 1000.0,
            "y": 550.0,
            "vx": 500.0,
            "vy": 0.0
        }
    ]
}

// Combat event
{
    "type": "combat_event",
    "event": "hit",
    "attacker_id": 123,
    "attacker_name": "alice",
    "victim_id": 456,
    "victim_name": "bob",
    "damage": 20
}

// Death event
{
    "type": "combat_event",
    "event": "death",
    "attacker_id": 123,
    "attacker_name": "alice",
    "victim_id": 456,
    "victim_name": "bob"
}

// Respawn event
{
    "type": "combat_event",
    "event": "respawn",
    "player_id": 456,
    "player_name": "bob",
    "x": 500.0,
    "y": 300.0
}
```

### 7.2 State Broadcast Updates

```cpp
// In GameLoop::broadcastState()
void GameLoop::broadcastState() {
    StateUpdate update;
    update.tick = tick_count_;
    
    // Players
    game_state_->forEachPlayer([&](const Player& player) {
        PlayerState state;
        state.id = player.id;
        state.username = player.username;
        state.x = player.position.x;
        state.y = player.position.y;
        state.rotation = player.rotation;
        state.health = player.health;
        state.is_alive = player.is_alive;
        state.kills = player.kills;
        state.deaths = player.deaths;
        
        update.players.push_back(state);
    });
    
    // Projectiles
    for (const auto& proj : projectile_manager_->getAll()) {
        if (proj.is_alive) {
            ProjectileState state;
            state.id = proj.id;
            state.owner_id = proj.owner_id;
            state.x = proj.position.x;
            state.y = proj.position.y;
            state.vx = proj.velocity.x;
            state.vy = proj.velocity.y;
            
            update.projectiles.push_back(state);
        }
    }
    
    // Combat events (for this tick only)
    update.combat_events = combat_events_for_broadcast_;
    combat_events_for_broadcast_.clear();
    
    // Push to output queue
    if (!output_queue_->push(update)) {
        std::cerr << "[GameLoop] Warning: Output queue full" << std::endl;
    }
}
```

---

## 8. Client Implementation

### 8.1 Shoot Input Handling

```javascript
// client/game.js - Add to GameClient class

setupEventListeners() {
    // ... existing keyboard/mouse code
    
    // Left-click to shoot
    this.canvas.addEventListener('click', (e) => {
        if (!this.myPlayerId) return;
        
        // Send shoot command
        this.ws.send(JSON.stringify({
            type: 'shoot'
        }));
        
        // Play shoot sound (optional)
        this.playSound('shoot');
    });
    
    // Or use mousedown for auto-fire
    this.isMouseDown = false;
    this.canvas.addEventListener('mousedown', () => {
        this.isMouseDown = true;
    });
    this.canvas.addEventListener('mouseup', () => {
        this.isMouseDown = false;
    });
    
    // Auto-fire loop (5 shots/sec max)
    setInterval(() => {
        if (this.isMouseDown && this.myPlayerId) {
            this.ws.send(JSON.stringify({ type: 'shoot' }));
        }
    }, 200);  // 200ms = 5 shots/sec
}
```

### 8.2 Render Projectiles

```javascript
// client/game.js

handleMessage(data) {
    switch (data.type) {
        case 'state':
            this.updateGameState(data);
            break;
        
        case 'combat_event':
            this.handleCombatEvent(data);
            break;
    }
}

updateGameState(data) {
    // Update players
    this.players.clear();
    for (const playerData of data.players) {
        this.players.set(playerData.id, playerData);
    }
    
    // Update projectiles
    this.projectiles = data.projectiles || [];
}

render() {
    const ctx = this.ctx;
    const canvas = this.canvas;
    
    // Clear and draw grid (existing code)
    // ...
    
    // Draw projectiles
    for (const proj of this.projectiles) {
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ffff00';  // Yellow
        ctx.fill();
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    // Draw players (existing code)
    for (const [id, player] of this.players) {
        // Draw dead players as gray
        if (!player.is_alive) {
            ctx.globalAlpha = 0.3;
        }
        
        // ... existing player rendering
        
        ctx.globalAlpha = 1.0;
    }
}
```

### 8.3 Kill Feed UI

```javascript
// client/game.js

constructor() {
    // ... existing code
    this.killFeed = [];  // Array of recent kills
}

handleCombatEvent(data) {
    if (data.event === 'death') {
        // Add to kill feed
        this.killFeed.push({
            attacker: data.attacker_name,
            victim: data.victim_name,
            timestamp: Date.now()
        });
        
        // Keep only last 5 kills
        if (this.killFeed.length > 5) {
            this.killFeed.shift();
        }
        
        // Play death sound
        this.playSound('death');
        
    } else if (data.event === 'respawn') {
        console.log(`${data.player_name} respawned`);
    }
}

render() {
    // ... existing rendering code
    
    // Draw kill feed (top-right corner)
    this.renderKillFeed();
}

renderKillFeed() {
    const ctx = this.ctx;
    const now = Date.now();
    
    let y = 50;
    for (const kill of this.killFeed) {
        // Fade out after 5 seconds
        const age = (now - kill.timestamp) / 1000;
        if (age > 5) continue;
        
        const alpha = Math.max(0, 1 - age / 5);
        ctx.globalAlpha = alpha;
        
        const text = `${kill.attacker} killed ${kill.victim}`;
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'right';
        ctx.fillText(text, this.canvas.width - 20, y);
        
        y += 25;
    }
    
    ctx.globalAlpha = 1.0;
}
```

### 8.4 HUD Updates

```html
<!-- client/index.html - Update HUD -->
<div id="hud">
    <div id="player-info">
        <span id="player-name"></span>
        <span id="player-health">Health: 100</span>
        <span id="player-score">K/D: 0/0</span>
    </div>
    <div id="kill-feed"></div>
</div>
```

```javascript
// Update HUD every frame
render() {
    // ... existing code
    
    const myPlayer = this.players.get(this.myPlayerId);
    if (myPlayer) {
        document.getElementById('player-health').textContent = 
            `Health: ${myPlayer.health}`;
        document.getElementById('player-score').textContent = 
            `K/D: ${myPlayer.kills}/${myPlayer.deaths}`;
    }
}
```

---

## 9. Performance Optimization

### 9.1 Collision Detection Bottleneck

**Problem**: O(nÂ²) collision checks slow down with many entities

```cpp
// BAD: Check every projectile vs every player
for (auto& proj : projectiles) {
    for (auto& player : players) {
        checkCollision(proj, player);  // O(nÂ²)
    }
}
```

**Solution 1**: Spatial partitioning (see section 4.3)

**Solution 2**: Early exit optimizations

```cpp
// GOOD: Skip impossible collisions
for (auto& proj : projectiles) {
    for (auto& player : players) {
        // Quick AABB check first (cheaper than circle)
        float dx = std::abs(proj.x - player.x);
        float dy = std::abs(proj.y - player.y);
        float max_dist = proj.radius + player.radius;
        
        if (dx > max_dist || dy > max_dist) {
            continue;  // Can't possibly collide
        }
        
        // Now do expensive circle check
        if (checkCircleCircle(proj, player)) {
            handleHit(proj, player);
        }
    }
}
```

### 9.2 Memory Allocation

**Problem**: Frequent vector resizing

```cpp
// BAD: Reallocates on every push
std::vector<CombatEvent> events;
for (/* many iterations */) {
    events.push_back(event);  // May reallocate
}
```

**Solution**: Reserve capacity

```cpp
// GOOD: Pre-allocate
std::vector<CombatEvent> events;
events.reserve(100);  // Allocate once
for (/* many iterations */) {
    events.push_back(event);  // No reallocation
}
```

### 9.3 Network Bandwidth

**Problem**: Sending all projectiles every tick (3.7 KB Ã— 60 = 222 KB/s)

**Solution**: Delta compression

```cpp
// Only send projectiles that changed
struct DeltaUpdate {
    std::vector<ProjectileState> new_projectiles;
    std::vector<uint64_t> removed_projectiles;
};

// Client maintains projectile list, applies delta
```

---

## 10. Testing

### 10.1 Collision Detection Tests

```cpp
// tests/unit/test_collision.cpp
#include <gtest/gtest.h>
#include "game/collision.h"

TEST(CollisionTest, CirclesOverlap) {
    Vec2 pos1 = {100.0f, 100.0f};
    Vec2 pos2 = {110.0f, 100.0f};
    
    bool hit = CollisionSystem::checkCircleCircle(pos1, 10.0f, pos2, 10.0f);
    
    EXPECT_TRUE(hit);  // Circles overlap
}

TEST(CollisionTest, CirclesDoNotOverlap) {
    Vec2 pos1 = {100.0f, 100.0f};
    Vec2 pos2 = {150.0f, 100.0f};
    
    bool hit = CollisionSystem::checkCircleCircle(pos1, 10.0f, pos2, 10.0f);
    
    EXPECT_FALSE(hit);  // Too far apart
}

TEST(CollisionTest, CirclesTouching) {
    Vec2 pos1 = {100.0f, 100.0f};
    Vec2 pos2 = {120.0f, 100.0f};  // Exactly 20 units apart
    
    bool hit = CollisionSystem::checkCircleCircle(pos1, 10.0f, pos2, 10.0f);
    
    EXPECT_TRUE(hit);  // Edge case: exactly touching
}
```

### 10.2 Combat System Tests

```cpp
// tests/unit/test_combat.cpp
TEST(CombatTest, DamageReducesHealth) {
    Player player;
    player.health = 100;
    
    applyDamage(player, 20);
    
    EXPECT_EQ(80, player.health);
}

TEST(CombatTest, DeathAtZeroHealth) {
    Player player;
    player.health = 20;
    player.is_alive = true;
    
    applyDamage(player, 20);
    
    EXPECT_EQ(0, player.health);
    EXPECT_FALSE(player.is_alive);
}

TEST(CombatTest, RespawnResetsHealth) {
    Player player;
    player.health = 0;
    player.is_alive = false;
    
    respawnPlayer(player);
    
    EXPECT_EQ(100, player.health);
    EXPECT_TRUE(player.is_alive);
}
```

### 10.3 Integration Test

```cpp
// tests/integration/test_combat_flow.cpp
TEST(IntegrationTest, FullCombatCycle) {
    // Setup
    GameState game_state;
    game_state.addPlayer(1, "alice");
    game_state.addPlayer(2, "bob");
    
    ProjectileManager proj_mgr;
    
    // Alice shoots bob
    auto alice = game_state.getPlayer(1);
    auto bob = game_state.getPlayer(2);
    
    Vec2 shoot_dir = {1.0f, 0.0f};
    proj_mgr.spawn(alice->id, alice->position, shoot_dir);
    
    // Update projectile 5 times (should hit bob)
    for (int i = 0; i < 5; i++) {
        proj_mgr.update(0.016f);
    }
    
    // Check collision
    auto& projectiles = proj_mgr.getAll();
    bool hit = false;
    for (auto& proj : projectiles) {
        if (CollisionSystem::checkCircleCircle(
                proj.position, proj.radius,
                bob->position, 20.0f)) {
            hit = true;
            break;
        }
    }
    
    EXPECT_TRUE(hit);
    
    // Apply damage
    if (hit) {
        bob->health -= 20;
    }
    
    EXPECT_EQ(80, bob->health);
}
```

---

## 11. Troubleshooting

### 11.1 Ghost Bullets

**Symptoms**: Projectiles disappear or don't register hits

**Causes**:
- Projectile moving too fast (skips over player in one tick)
- Collision check happens before position update
- Network packet loss

**Solutions**:

```cpp
// Continuous collision detection (raycast)
bool checkRayCircle(Vec2 ray_start, Vec2 ray_end, Vec2 circle_pos, float radius) {
    Vec2 d = ray_end - ray_start;
    Vec2 f = ray_start - circle_pos;
    
    float a = d.x * d.x + d.y * d.y;
    float b = 2 * (f.x * d.x + f.y * d.y);
    float c = f.x * f.x + f.y * f.y - radius * radius;
    
    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        return false;  // No intersection
    }
    
    float t = (-b - std::sqrt(discriminant)) / (2 * a);
    return (t >= 0 && t <= 1);  // Hit within this frame
}

// In checkCollisions()
Vec2 prev_pos = proj.position - proj.velocity * dt;
if (checkRayCircle(prev_pos, proj.position, player.position, player.radius)) {
    handleHit(proj, player);
}
```

### 11.2 Health Desync

**Symptoms**: Client shows different health than server

**Causes**:
- Client predicts damage before server confirms
- Network delay causes stale state
- Server doesn't broadcast health updates

**Solutions**:

```javascript
// Client: Always trust server state
handleMessage(data) {
    if (data.type === 'state') {
        for (const playerData of data.players) {
            // Overwrite local state with authoritative server state
            this.players.set(playerData.id, playerData);
        }
    }
}

// Server: Always broadcast health changes
if (player.health != player.prev_health) {
    broadcastHealthUpdate(player);
    player.prev_health = player.health;
}
```

### 11.3 Collision Accuracy

**Symptoms**: Hits register when projectile appears to miss

**Causes**:
- Client render position != server position (latency)
- Floating-point precision errors
- Radius values incorrect

**Solutions**:

```cpp
// Server: Use conservative collision (slightly smaller hitbox)
const float PLAYER_RADIUS = 20.0f;
const float HIT_TOLERANCE = 0.95f;  // 5% margin

bool hit = checkCircleCircle(proj_pos, proj_radius,
                             player_pos, PLAYER_RADIUS * HIT_TOLERANCE);
```

```javascript
// Client: Client-side prediction (show hit immediately)
if (checkLocalCollision(myProjectile, otherPlayer)) {
    showHitEffect(otherPlayer);  // Visual feedback
    // Wait for server confirmation to apply damage
}
```

---

## 12. Portfolio Showcase

### 12.1 Evidence Pack

**Create**: `docs/evidence/checkpoint-a/mvp-1.1/`

**Include**:

1. **Screenshot**: Kill feed showing multiple kills
   ```
   alice killed bob
   bob killed charlie
   charlie killed alice
   ```

2. **Video** (30 seconds):
   - Two players shooting each other
   - Health bars decreasing
   - Death animation
   - Respawn
   - Kill feed updates

3. **Performance Graph**:
   ```
   TPS vs Number of Projectiles
   
   60 â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   58 â”¤        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   56 â”¤      â•­â”€â•¯
   54 â”¤    â•­â”€â•¯
   52 â”¤  â•­â”€â•¯
   50 â”¤â•­â”€â•¯
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       0   20   40   60   80
          Projectiles
   ```

4. **Test Coverage Report**:
   ```
   File                    Lines   Coverage
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   collision.cpp           120     95%
   projectile_manager.cpp  85      88%
   combat_system.cpp       110     92%
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Total                   315     91%
   ```

### 12.2 Demo Script

**For recruiters/showcasing**:

```
1. Open client in two browser windows
2. Login as "alice" and "bob"
3. Alice moves to center of map
4. Bob shoots alice 5 times
5. Alice health: 100 â†’ 80 â†’ 60 â†’ 40 â†’ 20 â†’ 0 (dead)
6. Wait 3 seconds
7. Alice respawns at random location
8. Alice shoots bob back
9. Show kill feed: "alice killed bob", "bob killed alice"
10. Show performance: Stable 60 TPS with 50+ projectiles
```

### 12.3 Technical Highlights

**For resume/interviews**:

- âœ… Circle-circle collision detection (O(nÂ²) â†’ O(n) with spatial partitioning)
- âœ… Fixed timestep game loop (deterministic physics)
- âœ… Client-server state synchronization (60 updates/sec)
- âœ… Combat event system (hit, death, respawn)
- âœ… Performance: 60 TPS stable with 10 players + 50 projectiles
- âœ… Test coverage: 91% (unit + integration)
- âœ… Latency: <50ms hit registration (p99)

---

## ğŸ¯ MVP 1.1 Complete!

**You've successfully implemented**:
- âœ… Projectile shooting system (5 shots/second)
- âœ… Circle-circle collision detection (99% accuracy)
- âœ… Damage system (20 HP per hit)
- âœ… Death and respawn mechanics (3-second delay)
- âœ… Kill feed and score tracking
- âœ… Client-side combat rendering
- âœ… Performance optimization (60 TPS with 50+ projectiles)

**Evidence Pack Checklist**:
- [ ] Screenshot: Kill feed with multiple kills
- [ ] Video: 2-player combat (30 seconds)
- [ ] Performance graph: TPS vs projectile count
- [ ] Test coverage report: >75%

**Next MVP**:
- [MVP 1.2: Matchmaking System â†’](83-mvp-1.2-matchmaking.md) (2-3 weeks)
  - ELO rating algorithm
  - Redis-based matchmaking queue
  - Match search (Â±100 ELO)
  - Concurrent game sessions (10+)

---

â† [Back to MVP 1.0](81-mvp-1.0-basic-game-server.md) | [Next: MVP 1.2 â†’](83-mvp-1.2-matchmaking.md)
