# Quickstart 83: MVP 1.2 - Matchmaking System

‚Üê [Back to MVP 1.1](82-mvp-1.1-combat-system.md) | [Quickstart Index](README.md)

**Arena60 Checkpoint A - MVP 1.2: Matchmaking System**

**Duration**: 2-3 weeks  
**Difficulty**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Very Hard)  
**Prerequisites**: MVP 1.1 complete, Redis installed  
**Goal**: ELO-based matchmaking with concurrent game sessions  
**Lines**: ~1700

---

## üìñ Overview

**Scale from 2 players to 100+ concurrent users**

In MVP 1.1, you manually started games with 2+ players in the same room. Now we add production-grade matchmaking: players join a queue, the system finds fair matches (¬±100 ELO), and manages multiple concurrent game sessions.

**What You'll Build**:
- ELO rating system (K=25, starting 1200)
- Redis-based matchmaking queue (sorted sets)
- Match search algorithm (¬±100 ELO tolerance)
- Multiple concurrent game sessions (10+)
- Session lifecycle management (create, play, cleanup)
- Queue monitoring dashboard
- Match history tracking

**Learning Goals**:
- ‚úÖ Design scalable matchmaking algorithms
- ‚úÖ Use Redis for real-time data structures
- ‚úÖ Manage concurrent game sessions
- ‚úÖ Handle race conditions (multiple workers)
- ‚úÖ Implement fair matching (skill-based)
- ‚úÖ Monitor system health (queue depth, wait time)

**Success Criteria**:
- 100+ players can queue simultaneously
- Average wait time < 30 seconds (at 50+ online players)
- Match quality: 90%+ games within ¬±50 ELO
- Server handles 10+ concurrent game sessions
- No deadlocks or race conditions
- ELO updates correctly after each game

---

## üìö Table of Contents

1. [MVP 1.2 Specification](#1-mvp-12-specification)
2. [Architecture Design](#2-architecture-design)
3. [ELO Rating System](#3-elo-rating-system)
4. [Redis Data Structures](#4-redis-data-structures)
5. [Matchmaking Algorithm](#5-matchmaking-algorithm)
6. [Game Session Management](#6-game-session-management)
7. [Queue Monitoring](#7-queue-monitoring)
8. [Network Protocol](#8-network-protocol)
9. [Client Implementation](#9-client-implementation)
10. [Testing](#10-testing)
11. [Performance Tuning](#11-performance-tuning)
12. [Troubleshooting](#12-troubleshooting)

---

## 1. MVP 1.2 Specification

### 1.1 Features

**Must Have**:
- ‚úÖ ELO rating system (1200 starting, K=25)
- ‚úÖ Join matchmaking queue (single button)
- ‚úÖ Match search (¬±100 ELO, expand to ¬±200 after 30s)
- ‚úÖ Multiple concurrent games (10+)
- ‚úÖ Session isolation (players in different games don't see each other)
- ‚úÖ ELO update after game ends
- ‚úÖ Match history (last 10 games per player)
- ‚úÖ Queue status UI (position, estimated wait time)

**Out of Scope** (for MVP 1.3+):
- ‚ùå Ranked seasons
- ‚ùå Leaderboard display (MVP 1.3)
- ‚ùå Replay system
- ‚ùå Team matchmaking (this is 1v1 only)

### 1.2 Technical Requirements

**Performance**:
- Match search latency: < 100ms per search
- Queue throughput: 1000+ players/minute
- Concurrent game sessions: 10+ (target: 50+)
- Redis operations: < 5ms (p99)
- ELO calculation: < 1ms

**Quality**:
- Match fairness: 90%+ within ¬±50 ELO
- No duplicate matches (same 2 players within 5 minutes)
- No ghost players (stuck in queue after disconnect)
- Graceful session cleanup (no orphaned games)

**Scalability**:
- Queue size: 1000+ players
- Active sessions: 100+ (with horizontal scaling)
- Redis memory: < 100 MB for 1000 users

### 1.3 Deliverables

- [ ] Working matchmaking system (queue ‚Üí match ‚Üí play)
- [ ] ELO rating display and updates
- [ ] Redis monitoring dashboard
- [ ] Load test results (100 concurrent users)
- [ ] Evidence pack (`docs/evidence/checkpoint-a/mvp-1.2/`)
  - [ ] Screenshot: Queue UI with 10+ players
  - [ ] Video: End-to-end matchmaking flow (60 seconds)
  - [ ] Performance graph: Match search latency
  - [ ] Load test report: 100 concurrent users

---

## 2. Architecture Design

### 2.1 System Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                MVP 1.2 Architecture                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ         Client Layer                    ‚îÇ              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îÇ
‚îÇ  ‚îÇ  - Join Queue Button                    ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - Queue Status UI (position, ETA)      ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - ELO Rating Display                   ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - Match History                        ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ                      ‚îÇ                                     ‚îÇ
‚îÇ                      ‚ñº                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ      WebSocket Server (Main Thread)     ‚îÇ              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îÇ
‚îÇ  ‚îÇ  - Handle join_queue / leave_queue      ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - Notify match_found                   ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - Route messages to game sessions      ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ           ‚îÇ                        ‚îÇ                       ‚îÇ
‚îÇ           ‚ñº                        ‚ñº                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ Matchmaker       ‚îÇ    ‚îÇ Session Manager  ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ (Background)     ‚îÇ    ‚îÇ                  ‚îÇ            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§            ‚îÇ
‚îÇ  ‚îÇ Every 1 second:  ‚îÇ    ‚îÇ - Create session ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ 1. Get queue     ‚îÇ    ‚îÇ - Assign players ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ 2. Find matches  ‚îÇ    ‚îÇ - Start game     ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ 3. Create games  ‚îÇ    ‚îÇ - End game       ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ 4. Update ELO    ‚îÇ    ‚îÇ - Cleanup        ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ           ‚îÇ                        ‚îÇ                       ‚îÇ
‚îÇ           ‚ñº                        ‚ñº                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ              Redis                      ‚îÇ              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îÇ
‚îÇ  ‚îÇ  - matchmaking_queue (sorted set)       ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - active_sessions (hash)               ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - player_session_map (hash)            ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - match_history (list per player)      ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ           ‚îÇ                                                ‚îÇ
‚îÇ           ‚ñº                                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ           PostgreSQL                    ‚îÇ              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§              ‚îÇ
‚îÇ  ‚îÇ  - users (id, username, elo)            ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  - matches (id, p1, p2, winner, elo_Œî)  ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ                                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.2 Data Flow

```
Player Journey:
  1. Click "Find Match"
     ‚Üí Send join_queue message
     ‚Üí Server adds to Redis sorted set (key: ELO)
  
  2. Matchmaker (background thread, every 1s):
     ‚Üí Read queue from Redis
     ‚Üí Find best matches (¬±100 ELO)
     ‚Üí Remove matched players from queue
     ‚Üí Create game session
  
  3. Server sends match_found to both players
     ‚Üí Players transition to "in_game" state
     ‚Üí Game proceeds (MVP 1.0/1.1 logic)
  
  4. Game ends (one player dies 5 times)
     ‚Üí Calculate ELO changes
     ‚Üí Update PostgreSQL
     ‚Üí Update Redis cache
     ‚Üí Send match_end message
     ‚Üí Return to lobby
```

### 2.3 Threading Model

```cpp
// Main thread (network I/O)
WebSocketServer server(io_context, 8080);

// Game threads (one per session)
std::map<uint64_t, std::unique_ptr<GameSession>> sessions;
for (auto& [id, session] : sessions) {
    std::thread([session]() {
        session->run();  // 60 TPS game loop
    });
}

// Matchmaker thread (background worker)
std::thread matchmaker_thread([&]() {
    Matchmaker mm(redis, session_manager);
    while (running) {
        mm.tick();  // Find and create matches
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
});
```

---

## 3. ELO Rating System

### 3.1 ELO Algorithm

```cpp
// include/arena60/elo.h
#pragma once
#include <cmath>

namespace arena60 {

class EloRating {
public:
    // Calculate new ELO after a match
    static void calculate(int& winner_elo, int& loser_elo, int k_factor = 25);
    
    // Expected score (probability of winning)
    static double expectedScore(int player_elo, int opponent_elo);
    
private:
    static constexpr int DEFAULT_ELO = 1200;
    static constexpr int MIN_ELO = 0;
    static constexpr int MAX_ELO = 3000;
};

} // namespace arena60
```

```cpp
// src/game/elo.cpp
#include "arena60/elo.h"

namespace arena60 {

void EloRating::calculate(int& winner_elo, int& loser_elo, int k_factor) {
    // Expected scores
    double expected_winner = expectedScore(winner_elo, loser_elo);
    double expected_loser = expectedScore(loser_elo, winner_elo);
    
    // Actual scores (1 = win, 0 = loss)
    double actual_winner = 1.0;
    double actual_loser = 0.0;
    
    // Calculate changes
    int winner_change = static_cast<int>(k_factor * (actual_winner - expected_winner));
    int loser_change = static_cast<int>(k_factor * (actual_loser - expected_loser));
    
    // Apply changes
    winner_elo += winner_change;
    loser_elo += loser_change;
    
    // Clamp to valid range
    winner_elo = std::clamp(winner_elo, MIN_ELO, MAX_ELO);
    loser_elo = std::clamp(loser_elo, MIN_ELO, MAX_ELO);
}

double EloRating::expectedScore(int player_elo, int opponent_elo) {
    return 1.0 / (1.0 + std::pow(10.0, (opponent_elo - player_elo) / 400.0));
}

} // namespace arena60
```

### 3.2 ELO Examples

```cpp
// Example 1: Evenly matched (1200 vs 1200)
int player1_elo = 1200;
int player2_elo = 1200;

EloRating::calculate(player1_elo, player2_elo);  // Player 1 wins
// Result: player1_elo = 1212, player2_elo = 1188
// Change: ¬±12 (close to 50% expected)

// Example 2: Underdog wins (1100 vs 1300)
int underdog_elo = 1100;
int favorite_elo = 1300;

EloRating::calculate(underdog_elo, favorite_elo);  // Underdog wins!
// Result: underdog_elo = 1122, favorite_elo = 1278
// Change: +22 / -22 (bigger change for upset)

// Example 3: Expected result (1300 vs 1100)
int favorite_elo = 1300;
int underdog_elo = 1100;

EloRating::calculate(favorite_elo, underdog_elo);  // Favorite wins
// Result: favorite_elo = 1303, underdog_elo = 1097
// Change: +3 / -3 (small change for expected result)
```

### 3.3 Database Schema Updates

```sql
-- Update users table
ALTER TABLE users
    ADD COLUMN elo INTEGER DEFAULT 1200,
    ADD COLUMN games_played INTEGER DEFAULT 0,
    ADD COLUMN wins INTEGER DEFAULT 0,
    ADD COLUMN losses INTEGER DEFAULT 0;

CREATE INDEX idx_users_elo ON users(elo DESC);

-- Matches table
CREATE TABLE matches (
    id BIGSERIAL PRIMARY KEY,
    player1_id BIGINT REFERENCES users(id),
    player2_id BIGINT REFERENCES users(id),
    winner_id BIGINT REFERENCES users(id),
    
    player1_elo_before INTEGER NOT NULL,
    player2_elo_before INTEGER NOT NULL,
    player1_elo_after INTEGER NOT NULL,
    player2_elo_after INTEGER NOT NULL,
    
    duration_seconds INTEGER,
    player1_kills INTEGER DEFAULT 0,
    player2_kills INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP
);

CREATE INDEX idx_matches_player1 ON matches(player1_id, created_at DESC);
CREATE INDEX idx_matches_player2 ON matches(player2_id, created_at DESC);
CREATE INDEX idx_matches_created ON matches(created_at DESC);
```

---

## 4. Redis Data Structures

### 4.1 Redis Schema

```
Key: matchmaking_queue
Type: Sorted Set
Score: ELO rating
Members: player_id
TTL: None (manual cleanup)

Example:
  ZADD matchmaking_queue 1200 "user:123"
  ZADD matchmaking_queue 1250 "user:456"
  ZADD matchmaking_queue 1180 "user:789"

Query:
  ZRANGEBYSCORE matchmaking_queue 1150 1250  # Find players in ELO range
  ‚Üí ["user:123", "user:789"]


Key: queue_metadata:{player_id}
Type: Hash
Fields: joined_at, elo_at_join, search_radius
TTL: 5 minutes

Example:
  HSET queue_metadata:123 joined_at 1699876543
  HSET queue_metadata:123 elo_at_join 1200
  HSET queue_metadata:123 search_radius 100


Key: active_sessions
Type: Hash
Field: session_id
Value: JSON { players: [id1, id2], created_at, status }
TTL: 1 hour

Example:
  HSET active_sessions session:5001 '{"players":[123,456],"created_at":1699876543,"status":"playing"}'


Key: player_session_map
Type: Hash
Field: player_id
Value: session_id
TTL: None (cleanup on session end)

Example:
  HSET player_session_map 123 "session:5001"
  HSET player_session_map 456 "session:5001"


Key: match_history:{player_id}
Type: List
Value: JSON { opponent_id, result, elo_change, timestamp }
TTL: 30 days

Example:
  LPUSH match_history:123 '{"opponent_id":456,"result":"win","elo_change":+12,"timestamp":1699876543}'
  LTRIM match_history:123 0 9  # Keep last 10
```

### 4.2 Redis Client Wrapper

```cpp
// src/storage/redis_client.h
#pragma once
#include <string>
#include <vector>
#include <hiredis/hiredis.h>

namespace arena60 {

struct QueueEntry {
    uint64_t player_id;
    int elo;
    int64_t joined_at;
    int search_radius;
};

class RedisClient {
public:
    RedisClient(const std::string& host, int port);
    ~RedisClient();
    
    bool connect();
    void disconnect();
    
    // Queue operations
    bool addToQueue(uint64_t player_id, int elo);
    bool removeFromQueue(uint64_t player_id);
    std::vector<QueueEntry> getQueueInRange(int min_elo, int max_elo);
    size_t getQueueSize();
    
    // Session operations
    bool createSession(uint64_t session_id, uint64_t p1, uint64_t p2);
    bool endSession(uint64_t session_id);
    std::string getPlayerSession(uint64_t player_id);
    
    // Match history
    bool addMatchHistory(uint64_t player_id, const std::string& match_json);
    std::vector<std::string> getMatchHistory(uint64_t player_id, int limit = 10);
    
private:
    redisContext* context_{nullptr};
    std::string host_;
    int port_;
};

} // namespace arena60
```

```cpp
// src/storage/redis_client.cpp
#include "storage/redis_client.h"
#include <iostream>

namespace arena60 {

RedisClient::RedisClient(const std::string& host, int port)
    : host_(host), port_(port) {}

RedisClient::~RedisClient() {
    disconnect();
}

bool RedisClient::connect() {
    context_ = redisConnect(host_.c_str(), port_);
    
    if (context_ == nullptr || context_->err) {
        if (context_) {
            std::cerr << "Redis connection error: " << context_->errstr << std::endl;
        } else {
            std::cerr << "Redis connection error: can't allocate context" << std::endl;
        }
        return false;
    }
    
    std::cout << "Connected to Redis at " << host_ << ":" << port_ << std::endl;
    return true;
}

void RedisClient::disconnect() {
    if (context_) {
        redisFree(context_);
        context_ = nullptr;
    }
}

bool RedisClient::addToQueue(uint64_t player_id, int elo) {
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "ZADD matchmaking_queue %d user:%llu", elo, player_id)
    );
    
    if (!reply) {
        return false;
    }
    
    bool success = (reply->type == REDIS_REPLY_INTEGER && reply->integer >= 0);
    freeReplyObject(reply);
    
    // Store metadata
    int64_t now = std::chrono::system_clock::now().time_since_epoch().count();
    redisCommand(context_, "HSET queue_metadata:%llu joined_at %lld", player_id, now);
    redisCommand(context_, "HSET queue_metadata:%llu elo_at_join %d", player_id, elo);
    redisCommand(context_, "HSET queue_metadata:%llu search_radius 100", player_id);
    
    return success;
}

bool RedisClient::removeFromQueue(uint64_t player_id) {
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "ZREM matchmaking_queue user:%llu", player_id)
    );
    
    if (!reply) {
        return false;
    }
    
    bool success = (reply->type == REDIS_REPLY_INTEGER);
    freeReplyObject(reply);
    
    // Cleanup metadata
    redisCommand(context_, "DEL queue_metadata:%llu", player_id);
    
    return success;
}

std::vector<QueueEntry> RedisClient::getQueueInRange(int min_elo, int max_elo) {
    std::vector<QueueEntry> entries;
    
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "ZRANGEBYSCORE matchmaking_queue %d %d WITHSCORES", 
                    min_elo, max_elo)
    );
    
    if (!reply || reply->type != REDIS_REPLY_ARRAY) {
        if (reply) freeReplyObject(reply);
        return entries;
    }
    
    // Parse results (alternating member/score)
    for (size_t i = 0; i < reply->elements; i += 2) {
        std::string member = reply->element[i]->str;
        int elo = std::stoi(reply->element[i + 1]->str);
        
        // Extract player_id from "user:123"
        uint64_t player_id = std::stoull(member.substr(5));
        
        QueueEntry entry;
        entry.player_id = player_id;
        entry.elo = elo;
        
        entries.push_back(entry);
    }
    
    freeReplyObject(reply);
    return entries;
}

size_t RedisClient::getQueueSize() {
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "ZCARD matchmaking_queue")
    );
    
    if (!reply || reply->type != REDIS_REPLY_INTEGER) {
        if (reply) freeReplyObject(reply);
        return 0;
    }
    
    size_t size = reply->integer;
    freeReplyObject(reply);
    return size;
}

bool RedisClient::createSession(uint64_t session_id, uint64_t p1, uint64_t p2) {
    // Store session info
    std::string session_key = "session:" + std::to_string(session_id);
    std::string session_json = "{\"players\":[" + std::to_string(p1) + "," + 
                               std::to_string(p2) + "],\"status\":\"playing\"}";
    
    redisCommand(context_, "HSET active_sessions %s %s", 
                session_key.c_str(), session_json.c_str());
    
    // Map players to session
    redisCommand(context_, "HSET player_session_map %llu %s", p1, session_key.c_str());
    redisCommand(context_, "HSET player_session_map %llu %s", p2, session_key.c_str());
    
    return true;
}

bool RedisClient::endSession(uint64_t session_id) {
    std::string session_key = "session:" + std::to_string(session_id);
    
    // Get players from session
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "HGET active_sessions %s", session_key.c_str())
    );
    
    if (reply && reply->type == REDIS_REPLY_STRING) {
        // TODO: Parse JSON to get player IDs
        // For now, just cleanup
        freeReplyObject(reply);
    }
    
    // Remove session
    redisCommand(context_, "HDEL active_sessions %s", session_key.c_str());
    
    return true;
}

std::string RedisClient::getPlayerSession(uint64_t player_id) {
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "HGET player_session_map %llu", player_id)
    );
    
    if (!reply || reply->type != REDIS_REPLY_STRING) {
        if (reply) freeReplyObject(reply);
        return "";
    }
    
    std::string session_id = reply->str;
    freeReplyObject(reply);
    return session_id;
}

bool RedisClient::addMatchHistory(uint64_t player_id, const std::string& match_json) {
    redisCommand(context_, "LPUSH match_history:%llu %s", player_id, match_json.c_str());
    redisCommand(context_, "LTRIM match_history:%llu 0 9", player_id);  // Keep last 10
    return true;
}

std::vector<std::string> RedisClient::getMatchHistory(uint64_t player_id, int limit) {
    std::vector<std::string> history;
    
    redisReply* reply = static_cast<redisReply*>(
        redisCommand(context_, "LRANGE match_history:%llu 0 %d", player_id, limit - 1)
    );
    
    if (!reply || reply->type != REDIS_REPLY_ARRAY) {
        if (reply) freeReplyObject(reply);
        return history;
    }
    
    for (size_t i = 0; i < reply->elements; i++) {
        history.push_back(reply->element[i]->str);
    }
    
    freeReplyObject(reply);
    return history;
}

} // namespace arena60
```

---

## 5. Matchmaking Algorithm

### 5.1 Matchmaker Core

```cpp
// src/game/matchmaker.h
#pragma once
#include <memory>
#include <vector>
#include "storage/redis_client.h"
#include "game/session_manager.h"

namespace arena60 {

struct MatchCandidate {
    uint64_t player_id;
    int elo;
    int64_t wait_time_seconds;
};

class Matchmaker {
public:
    Matchmaker(std::shared_ptr<RedisClient> redis,
               std::shared_ptr<SessionManager> session_mgr);
    
    void tick();  // Called every 1 second
    
private:
    void findMatches();
    std::vector<MatchCandidate> getCandidates();
    bool tryMatch(const MatchCandidate& p1, const MatchCandidate& p2);
    int getSearchRadius(int wait_time_seconds);
    
    std::shared_ptr<RedisClient> redis_;
    std::shared_ptr<SessionManager> session_mgr_;
    
    static constexpr int INITIAL_SEARCH_RADIUS = 100;
    static constexpr int MAX_SEARCH_RADIUS = 500;
    static constexpr int RADIUS_INCREASE_PER_30S = 100;
};

} // namespace arena60
```

```cpp
// src/game/matchmaker.cpp
#include "game/matchmaker.h"
#include <algorithm>
#include <iostream>

namespace arena60 {

Matchmaker::Matchmaker(std::shared_ptr<RedisClient> redis,
                       std::shared_ptr<SessionManager> session_mgr)
    : redis_(redis), session_mgr_(session_mgr) {}

void Matchmaker::tick() {
    size_t queue_size = redis_->getQueueSize();
    
    if (queue_size < 2) {
        return;  // Need at least 2 players
    }
    
    std::cout << "[Matchmaker] Queue size: " << queue_size << std::endl;
    
    findMatches();
}

void Matchmaker::findMatches() {
    auto candidates = getCandidates();
    
    if (candidates.size() < 2) {
        return;
    }
    
    // Sort by ELO (for optimal matching)
    std::sort(candidates.begin(), candidates.end(),
              [](const MatchCandidate& a, const MatchCandidate& b) {
                  return a.elo < b.elo;
              });
    
    // Greedy matching: pair adjacent players in ELO order
    std::vector<bool> matched(candidates.size(), false);
    
    for (size_t i = 0; i < candidates.size(); i++) {
        if (matched[i]) continue;
        
        const auto& p1 = candidates[i];
        int search_radius = getSearchRadius(p1.wait_time_seconds);
        
        // Find best match
        for (size_t j = i + 1; j < candidates.size(); j++) {
            if (matched[j]) continue;
            
            const auto& p2 = candidates[j];
            int elo_diff = std::abs(p2.elo - p1.elo);
            
            if (elo_diff <= search_radius) {
                // Found a match!
                if (tryMatch(p1, p2)) {
                    matched[i] = true;
                    matched[j] = true;
                    std::cout << "[Matchmaker] Matched players " << p1.player_id 
                              << " (ELO: " << p1.elo << ") and " << p2.player_id 
                              << " (ELO: " << p2.elo << ", diff: " << elo_diff << ")" 
                              << std::endl;
                }
                break;
            }
        }
    }
}

std::vector<MatchCandidate> Matchmaker::getCandidates() {
    std::vector<MatchCandidate> candidates;
    
    // Get all players in queue (0 to 3000 ELO range)
    auto queue_entries = redis_->getQueueInRange(0, 3000);
    
    auto now = std::chrono::system_clock::now().time_since_epoch().count();
    
    for (const auto& entry : queue_entries) {
        MatchCandidate candidate;
        candidate.player_id = entry.player_id;
        candidate.elo = entry.elo;
        candidate.wait_time_seconds = (now - entry.joined_at) / 1'000'000'000;
        
        candidates.push_back(candidate);
    }
    
    return candidates;
}

bool Matchmaker::tryMatch(const MatchCandidate& p1, const MatchCandidate& p2) {
    // Remove from queue
    if (!redis_->removeFromQueue(p1.player_id) || 
        !redis_->removeFromQueue(p2.player_id)) {
        std::cerr << "[Matchmaker] Failed to remove players from queue" << std::endl;
        return false;
    }
    
    // Create game session
    uint64_t session_id = session_mgr_->createSession(p1.player_id, p2.player_id);
    
    if (session_id == 0) {
        std::cerr << "[Matchmaker] Failed to create game session" << std::endl;
        // Re-add to queue (retry logic)
        redis_->addToQueue(p1.player_id, p1.elo);
        redis_->addToQueue(p2.player_id, p2.elo);
        return false;
    }
    
    // Store session in Redis
    redis_->createSession(session_id, p1.player_id, p2.player_id);
    
    return true;
}

int Matchmaker::getSearchRadius(int wait_time_seconds) {
    // Start with ¬±100 ELO
    // Increase by 100 every 30 seconds
    // Cap at ¬±500 ELO
    
    int radius = INITIAL_SEARCH_RADIUS + 
                 (wait_time_seconds / 30) * RADIUS_INCREASE_PER_30S;
    
    return std::min(radius, MAX_SEARCH_RADIUS);
}

} // namespace arena60
```

### 5.2 Alternative: Priority-Based Matching

```cpp
// For production: prioritize long-waiting players
struct MatchCandidate {
    uint64_t player_id;
    int elo;
    int wait_time_seconds;
    
    // Priority score (higher = match first)
    double priority() const {
        return wait_time_seconds * 10.0;  // 10 points per second
    }
};

void Matchmaker::findMatchesPriority() {
    auto candidates = getCandidates();
    
    // Sort by priority (longest wait first)
    std::sort(candidates.begin(), candidates.end(),
              [](const MatchCandidate& a, const MatchCandidate& b) {
                  return a.priority() > b.priority();
              });
    
    // Match high-priority players first
    // ...
}
```

---

## 6. Game Session Management

### 6.1 Session Manager

```cpp
// src/game/session_manager.h
#pragma once
#include <map>
#include <memory>
#include <thread>
#include <atomic>
#include "game/game_session.h"

namespace arena60 {

class SessionManager {
public:
    uint64_t createSession(uint64_t player1_id, uint64_t player2_id);
    void endSession(uint64_t session_id);
    GameSession* getSession(uint64_t session_id);
    
    size_t getActiveSessionCount() const;
    void cleanup();  // Remove ended sessions
    
private:
    std::map<uint64_t, std::unique_ptr<GameSession>> sessions_;
    std::atomic<uint64_t> next_session_id_{1};
    mutable std::mutex mutex_;
};

} // namespace arena60
```

```cpp
// src/game/session_manager.cpp
#include "game/session_manager.h"
#include <iostream>

namespace arena60 {

uint64_t SessionManager::createSession(uint64_t player1_id, uint64_t player2_id) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    uint64_t session_id = next_session_id_++;
    
    auto session = std::make_unique<GameSession>(session_id, player1_id, player2_id);
    
    // Start game thread
    session->start();
    
    sessions_[session_id] = std::move(session);
    
    std::cout << "[SessionManager] Created session " << session_id 
              << " for players " << player1_id << " and " << player2_id << std::endl;
    
    return session_id;
}

void SessionManager::endSession(uint64_t session_id) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = sessions_.find(session_id);
    if (it != sessions_.end()) {
        it->second->stop();
        sessions_.erase(it);
        
        std::cout << "[SessionManager] Ended session " << session_id << std::endl;
    }
}

GameSession* SessionManager::getSession(uint64_t session_id) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = sessions_.find(session_id);
    return (it != sessions_.end()) ? it->second.get() : nullptr;
}

size_t SessionManager::getActiveSessionCount() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return sessions_.size();
}

void SessionManager::cleanup() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // Remove ended sessions
    for (auto it = sessions_.begin(); it != sessions_.end(); ) {
        if (it->second->isEnded()) {
            std::cout << "[SessionManager] Cleaning up session " << it->first << std::endl;
            it = sessions_.erase(it);
        } else {
            ++it;
        }
    }
}

} // namespace arena60
```

### 6.2 Game Session (Isolated Instance)

```cpp
// src/game/game_session.h
#pragma once
#include <atomic>
#include <thread>
#include <memory>
#include "game/game_state.h"

namespace arena60 {

class GameSession {
public:
    GameSession(uint64_t session_id, uint64_t player1_id, uint64_t player2_id);
    ~GameSession();
    
    void start();
    void stop();
    bool isEnded() const { return ended_; }
    
    uint64_t getSessionId() const { return session_id_; }
    uint64_t getWinnerId() const { return winner_id_; }
    
    // Game loop (runs at 60 TPS)
    void run();
    
private:
    void checkWinCondition();
    
    uint64_t session_id_;
    uint64_t player1_id_;
    uint64_t player2_id_;
    uint64_t winner_id_{0};
    
    std::unique_ptr<GameState> game_state_;
    std::unique_ptr<std::thread> game_thread_;
    
    std::atomic<bool> running_{false};
    std::atomic<bool> ended_{false};
    
    static constexpr int KILLS_TO_WIN = 5;
};

} // namespace arena60
```

```cpp
// src/game/game_session.cpp
#include "game/game_session.h"
#include <iostream>

namespace arena60 {

GameSession::GameSession(uint64_t session_id, uint64_t player1_id, uint64_t player2_id)
    : session_id_(session_id)
    , player1_id_(player1_id)
    , player2_id_(player2_id)
    , game_state_(std::make_unique<GameState>()) {
    
    // Add players to game state
    game_state_->addPlayer(player1_id, "Player1");  // TODO: Get real username
    game_state_->addPlayer(player2_id, "Player2");
}

GameSession::~GameSession() {
    stop();
}

void GameSession::start() {
    running_ = true;
    
    game_thread_ = std::make_unique<std::thread>([this]() {
        run();
    });
}

void GameSession::stop() {
    if (running_) {
        running_ = false;
        
        if (game_thread_ && game_thread_->joinable()) {
            game_thread_->join();
        }
    }
}

void GameSession::run() {
    std::cout << "[Session " << session_id_ << "] Game started" << std::endl;
    
    const int target_tps = 60;
    auto frame_time = std::chrono::milliseconds(1000 / target_tps);
    
    while (running_) {
        auto tick_start = std::chrono::steady_clock::now();
        
        // Game tick (same as GameLoop from MVP 1.0/1.1)
        // processInputs();
        // updatePhysics(dt);
        // checkCollisions();
        // broadcastState();
        
        checkWinCondition();
        
        if (ended_) {
            break;
        }
        
        // Sleep until next tick
        auto elapsed = std::chrono::steady_clock::now() - tick_start;
        if (elapsed < frame_time) {
            std::this_thread::sleep_for(frame_time - elapsed);
        }
    }
    
    std::cout << "[Session " << session_id_ << "] Game ended, winner: " 
              << winner_id_ << std::endl;
    
    ended_ = true;
}

void GameSession::checkWinCondition() {
    auto player1 = game_state_->getPlayer(player1_id_);
    auto player2 = game_state_->getPlayer(player2_id_);
    
    if (!player1 || !player2) return;
    
    if (player1->kills >= KILLS_TO_WIN) {
        winner_id_ = player1_id_;
        running_ = false;
    } else if (player2->kills >= KILLS_TO_WIN) {
        winner_id_ = player2_id_;
        running_ = false;
    }
}

} // namespace arena60
```

---

## 7. Queue Monitoring

### 7.1 Monitoring Dashboard

```cpp
// src/monitoring/queue_monitor.h
#pragma once
#include <memory>
#include "storage/redis_client.h"

namespace arena60 {

struct QueueMetrics {
    size_t queue_size;
    double avg_wait_time_seconds;
    double p95_wait_time_seconds;
    size_t active_sessions;
    double match_rate_per_minute;
};

class QueueMonitor {
public:
    QueueMonitor(std::shared_ptr<RedisClient> redis);
    
    QueueMetrics getMetrics();
    void logMetrics();
    
private:
    std::shared_ptr<RedisClient> redis_;
    
    // Rolling window for match rate
    std::deque<int64_t> recent_matches_;  // Timestamps
    static constexpr int MATCH_WINDOW_SECONDS = 60;
};

} // namespace arena60
```

### 7.2 Prometheus Metrics (Optional)

```cpp
// Export to Prometheus
#include <prometheus/counter.h>
#include <prometheus/gauge.h>
#include <prometheus/histogram.h>

class MetricsExporter {
public:
    MetricsExporter() {
        // Counters
        matches_total_ = prometheus::BuildCounter()
            .Name("arena60_matches_total")
            .Help("Total number of matches created")
            .Register(*registry_);
        
        // Gauges
        queue_size_ = prometheus::BuildGauge()
            .Name("arena60_queue_size")
            .Help("Current number of players in queue")
            .Register(*registry_);
        
        // Histograms
        wait_time_ = prometheus::BuildHistogram()
            .Name("arena60_queue_wait_time_seconds")
            .Help("Time players spend in queue")
            .Register(*registry_);
    }
    
    void recordMatch() {
        matches_total_->Increment();
    }
    
    void updateQueueSize(size_t size) {
        queue_size_->Set(size);
    }
    
    void recordWaitTime(double seconds) {
        wait_time_->Observe(seconds);
    }
    
private:
    std::shared_ptr<prometheus::Registry> registry_;
    prometheus::Counter* matches_total_;
    prometheus::Gauge* queue_size_;
    prometheus::Histogram* wait_time_;
};
```

---

## 8. Network Protocol

### 8.1 New Message Types

**Client ‚Üí Server**:

```json
// Join matchmaking queue
{
    "type": "join_queue"
}

// Leave queue
{
    "type": "leave_queue"
}

// Get queue status
{
    "type": "queue_status"
}
```

**Server ‚Üí Client**:

```json
// Queue joined
{
    "type": "queue_joined",
    "position": 5,
    "estimated_wait_seconds": 15
}

// Queue status update (every 5 seconds)
{
    "type": "queue_update",
    "position": 3,
    "estimated_wait_seconds": 8,
    "players_in_queue": 20
}

// Match found!
{
    "type": "match_found",
    "session_id": "session:5001",
    "opponent_id": 456,
    "opponent_name": "bob",
    "opponent_elo": 1250
}

// Match ended
{
    "type": "match_ended",
    "winner_id": 123,
    "your_elo_before": 1200,
    "your_elo_after": 1212,
    "elo_change": +12,
    "opponent_elo_before": 1250,
    "opponent_elo_after": 1238
}
```

---

## 9. Client Implementation

### 9.1 Queue UI

```html
<!-- client/index.html -->
<div id="lobby-screen">
    <div id="player-card">
        <h2 id="player-name-display"></h2>
        <div class="elo-display">
            <span class="elo-label">ELO Rating</span>
            <span class="elo-value" id="player-elo">1200</span>
        </div>
        <div class="stats">
            <span>Wins: <span id="wins">0</span></span>
            <span>Losses: <span id="losses">0</span></span>
        </div>
    </div>
    
    <button id="find-match-btn" class="primary-button">
        Find Match
    </button>
    
    <div id="queue-status" style="display: none;">
        <div class="spinner"></div>
        <p>Searching for opponent...</p>
        <p>Position in queue: <span id="queue-position">-</span></p>
        <p>Estimated wait: <span id="queue-eta">-</span>s</p>
        <button id="cancel-queue-btn">Cancel</button>
    </div>
    
    <div id="match-history">
        <h3>Recent Matches</h3>
        <div id="match-history-list"></div>
    </div>
</div>
```

### 9.2 Matchmaking Logic

```javascript
// client/game.js - Add to GameClient class

joinQueue() {
    this.ws.send(JSON.stringify({ type: 'join_queue' }));
    
    document.getElementById('find-match-btn').style.display = 'none';
    document.getElementById('queue-status').style.display = 'block';
}

leaveQueue() {
    this.ws.send(JSON.stringify({ type: 'leave_queue' }));
    
    document.getElementById('find-match-btn').style.display = 'block';
    document.getElementById('queue-status').style.display = 'none';
}

handleMessage(data) {
    switch (data.type) {
        case 'queue_joined':
            console.log('Joined queue, position:', data.position);
            break;
        
        case 'queue_update':
            document.getElementById('queue-position').textContent = data.position;
            document.getElementById('queue-eta').textContent = data.estimated_wait_seconds;
            break;
        
        case 'match_found':
            console.log('Match found! Opponent:', data.opponent_name, 'ELO:', data.opponent_elo);
            this.startMatch(data.session_id, data.opponent_id);
            break;
        
        case 'match_ended':
            this.showMatchResults(data);
            break;
    }
}

startMatch(session_id, opponent_id) {
    this.currentSessionId = session_id;
    this.opponentId = opponent_id;
    
    // Transition to game screen
    document.getElementById('lobby-screen').style.display = 'none';
    document.getElementById('game-screen').style.display = 'block';
    
    this.startGameLoop();
}

showMatchResults(data) {
    const result = (data.winner_id === this.myPlayerId) ? 'Victory' : 'Defeat';
    const elo_change_str = (data.elo_change >= 0) ? '+' + data.elo_change : data.elo_change;
    
    alert(`${result}!\nELO: ${data.your_elo_before} ‚Üí ${data.your_elo_after} (${elo_change_str})`);
    
    // Update UI
    document.getElementById('player-elo').textContent = data.your_elo_after;
    
    // Return to lobby
    document.getElementById('game-screen').style.display = 'none';
    document.getElementById('lobby-screen').style.display = 'block';
}
```

---

## 10. Testing

### 10.1 Unit Tests

```cpp
// tests/unit/test_elo.cpp
TEST(EloTest, EvenMatch) {
    int p1_elo = 1200;
    int p2_elo = 1200;
    
    EloRating::calculate(p1_elo, p2_elo);
    
    EXPECT_EQ(1212, p1_elo);
    EXPECT_EQ(1188, p2_elo);
}

TEST(EloTest, UnderdogWin) {
    int underdog = 1100;
    int favorite = 1300;
    
    EloRating::calculate(underdog, favorite);
    
    // Underdog should gain more
    EXPECT_GT(underdog - 1100, 15);
    EXPECT_LT(favorite - 1300, -15);
}
```

### 10.2 Integration Test

```cpp
// tests/integration/test_matchmaking.cpp
TEST(MatchmakingTest, FullFlow) {
    // Setup
    auto redis = std::make_shared<RedisClient>("localhost", 6379);
    redis->connect();
    
    auto session_mgr = std::make_shared<SessionManager>();
    Matchmaker mm(redis, session_mgr);
    
    // Add 2 players to queue
    redis->addToQueue(1, 1200);
    redis->addToQueue(2, 1210);
    
    // Run matchmaker
    mm.tick();
    
    // Verify match created
    EXPECT_EQ(0, redis->getQueueSize());
    EXPECT_EQ(1, session_mgr->getActiveSessionCount());
}
```

### 10.3 Load Test

```python
# tests/load/load_test.py
import asyncio
import websockets
import json
import time

async def simulate_player(player_id):
    uri = "ws://localhost:8080"
    async with websockets.connect(uri) as ws:
        # Login
        await ws.send(json.dumps({
            "type": "login",
            "username": f"player{player_id}",
            "password": "test123"
        }))
        
        response = await ws.recv()
        data = json.loads(response)
        
        if data["type"] != "login_success":
            return
        
        # Join queue
        await ws.send(json.dumps({"type": "join_queue"}))
        
        # Wait for match
        start_time = time.time()
        while True:
            response = await ws.recv()
            data = json.loads(response)
            
            if data["type"] == "match_found":
                wait_time = time.time() - start_time
                print(f"Player {player_id} matched in {wait_time:.2f}s")
                break
            
            if time.time() - start_time > 60:
                print(f"Player {player_id} timeout")
                break

async def main():
    tasks = [simulate_player(i) for i in range(100)]
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 11. Performance Tuning

### 11.1 Redis Optimization

```bash
# redis.conf
maxmemory 2gb
maxmemory-policy allkeys-lru

# Enable persistence (optional)
save 900 1
save 300 10
save 60 10000

# AOF for durability
appendonly yes
appendfsync everysec
```

### 11.2 Connection Pooling

```cpp
// For high load, use connection pool
class RedisConnectionPool {
public:
    RedisConnectionPool(int pool_size, const std::string& host, int port) {
        for (int i = 0; i < pool_size; i++) {
            auto client = std::make_shared<RedisClient>(host, port);
            client->connect();
            pool_.push(client);
        }
    }
    
    std::shared_ptr<RedisClient> acquire() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !pool_.empty(); });
        
        auto client = pool_.front();
        pool_.pop();
        return client;
    }
    
    void release(std::shared_ptr<RedisClient> client) {
        std::lock_guard<std::mutex> lock(mutex_);
        pool_.push(client);
        cv_.notify_one();
    }
    
private:
    std::queue<std::shared_ptr<RedisClient>> pool_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
```

---

## 12. Troubleshooting

### 12.1 Players Stuck in Queue

**Symptoms**: Queue size increases but no matches created

**Causes**:
- Matchmaker thread crashed
- Redis connection lost
- ELO ranges too narrow

**Solutions**:

```cpp
// Add health check
void Matchmaker::tick() {
    try {
        findMatches();
    } catch (const std::exception& e) {
        std::cerr << "[Matchmaker] Error: " << e.what() << std::endl;
        // Don't crash, just log and continue
    }
}

// Periodically verify Redis connection
if (!redis_->ping()) {
    std::cerr << "[Matchmaker] Redis connection lost, reconnecting..." << std::endl;
    redis_->reconnect();
}
```

### 12.2 Duplicate Matches

**Symptoms**: Same 2 players matched multiple times in a row

**Causes**:
- Race condition (multiple matchmaker workers)
- Redis ZREM not atomic
- Queue not properly cleaned

**Solutions**:

```cpp
// Use Redis transactions (MULTI/EXEC)
bool Matchmaker::tryMatchAtomic(uint64_t p1, uint64_t p2) {
    // MULTI
    redisCommand(context, "MULTI");
    
    // Check both players still in queue
    redisCommand(context, "ZSCORE matchmaking_queue user:%llu", p1);
    redisCommand(context, "ZSCORE matchmaking_queue user:%llu", p2);
    
    // Remove both
    redisCommand(context, "ZREM matchmaking_queue user:%llu", p1);
    redisCommand(context, "ZREM matchmaking_queue user:%llu", p2);
    
    // EXEC (atomic)
    redisReply* reply = redisCommand(context, "EXEC");
    
    // Check if transaction succeeded
    bool success = (reply && reply->type == REDIS_REPLY_ARRAY);
    freeReplyObject(reply);
    
    return success;
}
```

---

## üéØ MVP 1.2 Complete!

**You've successfully implemented**:
- ‚úÖ ELO rating system (K=25, 1200 starting)
- ‚úÖ Redis-based matchmaking queue
- ‚úÖ Match search algorithm (¬±100 ELO, expanding)
- ‚úÖ Multiple concurrent game sessions (10+)
- ‚úÖ Session lifecycle management
- ‚úÖ Queue monitoring and metrics
- ‚úÖ Load tested (100 concurrent users)

**Evidence Pack Checklist**:
- [ ] Screenshot: Queue UI with 10+ players
- [ ] Video: Full matchmaking flow (60 seconds)
- [ ] Performance graph: Match search latency
- [ ] Load test report: 100 concurrent users

**Next MVP**:
- [MVP 1.3: Statistics & Ranking ‚Üí](84-mvp-1.3-stats-ranking.md) (2-3 weeks)
  - Post-match statistics
  - ELO leaderboard (top 100)
  - Player profiles
  - Match replays (optional)

---

‚Üê [Back to MVP 1.1](82-mvp-1.1-combat-system.md) | [Next: MVP 1.3 ‚Üí](84-mvp-1.3-stats-ranking.md)
